// Command go-chat-backend is the main entrypoint for the Chat Backend API.
//
// This service provides a REST API for chat-based Q&A on market research data,
// exposing endpoints under /api/v*. It is designed as a production-ready,
// observable microservice with the following key features:
//
//   - Gin framework with middleware for compression, tracing, and request context.
//   - SQLite persistence via GORM (with optional auto-migration in dev).
//   - Pluggable semantic search index built from Markdown datasets.
//   - OpenTelemetry instrumentation for traces and metrics.
//   - Structured JSON logging via zerolog (with console pretty mode).
//   - Graceful shutdown on SIGINT/SIGTERM with configurable timeouts.
//   - Optional Swagger UI for API exploration.
//
// Configuration is sourced from environment variables and a config file
// (see internal/config). Build metadata (version, commit, date) is injected
// at compile time using -ldflags.
//
// Example:
//
//	LOG_LEVEL=debug DATA_MD=./data/data.md ./go-chat-backend
//
// For schema and endpoint documentation, see the generated Swagger spec
// under /swagger when enabled.
package main

import (
	"bytes"
	"context"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/joho/godotenv"

	"github.com/gin-contrib/gzip"
	"github.com/gin-gonic/gin"
	"github.com/rs/zerolog"
	zlog "github.com/rs/zerolog/log"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"gorm.io/plugin/opentelemetry/tracing"

	"github.com/tbourn/go-chat-backend/internal/config"
	httpapi "github.com/tbourn/go-chat-backend/internal/http"
	"github.com/tbourn/go-chat-backend/internal/observability"
	"github.com/tbourn/go-chat-backend/internal/repo"
	"github.com/tbourn/go-chat-backend/internal/search"
	"github.com/tbourn/go-chat-backend/internal/sysutil"

	// swagger docs (generated by `swag init`)
	_ "github.com/tbourn/go-chat-backend/docs"
)

// Populated via -ldflags at build time (see Dockerfile)
var (
	version = "dev"
	commit  = "unknown"
	date    = "unknown"
)

// @title           Go Chat Backend API
// @version         1.0.0
// @description     Public REST API for chat-based Q&A over market research data.
//
// @contact.name    Thomas Bournaveas
// @contact.url     https://thomasbournaveas.com
// @contact.email   thomas.bournaveas@gmail.com
//
// @license.name    MIT
// @license.url     https://opensource.org/licenses/MIT
//
// @BasePath        /api/v1
// @schemes         http
// @accept          json
// @produce         json
//
// @tag.name        Chats
// @tag.description Manage chat sessions and messages
//
// @tag.name        Feedback
// @tag.description Submit feedback on assistant messages
//
// @tag.name        Messages
// @tag.description Send messages and get assistant replies
//
// @externalDocs.description Project documentation
// @externalDocs.url         https://github.com/tbourn/go-chat-backend
func main() {
	// Load .env files (non-fatal). Precedence: process env > .env.local > .env
	_ = godotenv.Load(".env")
	_ = godotenv.Overload(".env.local")

	// ---------- Config ----------
	cfg := config.MustLoad() // single source of truth

	// ---------- Logging ----------
	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
	sysutil.SetLogLevel(cfg.LogLevel)
	if cfg.LogPretty {
		zlog.Logger = zlog.Output(zerolog.ConsoleWriter{Out: os.Stdout})
	} else {
		zlog.Logger = zerolog.New(os.Stdout).With().Timestamp().Logger()
	}

	// ---------- Gin mode ----------
	switch strings.ToLower(cfg.GinMode) { // require GinMode in config
	case "debug":
		gin.SetMode(gin.DebugMode)
	case "test":
		gin.SetMode(gin.TestMode)
	default:
		gin.SetMode(gin.ReleaseMode)
	}

	// ---------- OpenTelemetry (tracing) ----------
	otelShutdown, err := observability.SetupOTel(context.Background(), cfg.OTEL, version)
	if err != nil {
		zlog.Fatal().Err(err).Msg("otel setup failed")
	}
	defer func() {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_ = otelShutdown(ctx)
	}()

	// ---------- Database ----------
	db, err := repo.OpenSQLite(cfg.DBPath)
	if err != nil {
		zlog.Fatal().Err(err).Str("db_path", cfg.DBPath).Msg("db open failed")
	}
	if sqlDB, e := db.DB(); e == nil {
		defer sqlDB.Close()
	}
	if err := db.Use(tracing.NewPlugin()); err != nil {
		zlog.Warn().Err(err).Msg("gorm otel plugin failed")
	}
	if err := repo.AutoMigrate(db); err != nil {
		zlog.Fatal().Err(err).Msg("db migration failed")
	}

	// ---------- Search index (from data.md) ----------
	// Prefer cfg.DataMD override, then cfg.DataPath, then sensible default.
	dataPath := sysutil.FirstNonEmpty(cfg.DataMD, cfg.DataPath, "data/data.md")
	mdBytes, prepErr := search.PrepareMarkdownInMemory(dataPath)
	if prepErr != nil {
		zlog.Warn().Err(prepErr).Str("data_path", dataPath).
			Msg("markdown preprocess failed; indexing raw file")
		if raw, readErr := os.ReadFile(dataPath); readErr == nil {
			mdBytes = raw
		} else {
			mdBytes = []byte{}
		}
	}
	idx, idxErr := search.NewIndexFromReader(
		bytes.NewReader(mdBytes),
		search.WithMinParagraphRunes(1),
	)
	if idxErr != nil {
		zlog.Warn().Err(idxErr).Str("data_path", dataPath).
			Msg("index build encountered an error; bot may decline more often")
	}

	// Similarity threshold: keep permissive default for recall if unset
	if cfg.Threshold <= 0 {
		cfg.Threshold = 0.10
	}

	// ---------- Router & middleware ----------
	r := gin.New()
	r.Use(gzip.Gzip(gzip.DefaultCompression))

	// Simple user identity stub
	r.Use(func(c *gin.Context) {
		uid := strings.TrimSpace(c.GetHeader("X-User-ID"))
		if uid == "" {
			uid = "demo-user"
		}
		c.Set("userID", uid)
		c.Next()
	})

	// Wire routes (otel, metrics, cors, security, api, etc. are set inside)
	httpapi.RegisterRoutes(r, db, idx, cfg)

	// Swagger UI (opt-in)
	if cfg.SwaggerEnabled {
		r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	}

	// ---------- HTTP server ----------
	addr := ":" + cfg.Port
	srv := &http.Server{
		Addr:              addr,
		Handler:           r,
		ReadTimeout:       cfg.ReadTimeout,
		ReadHeaderTimeout: cfg.ReadHeaderTimeout,
		WriteTimeout:      cfg.WriteTimeout,
		IdleTimeout:       cfg.IdleTimeout,
		MaxHeaderBytes:    cfg.MaxHeaderBytes,
	}

	// Start
	go func() {
		zlog.Info().
			Str("addr", addr).
			Str("version", version).
			Str("commit", commit).
			Str("date", date).
			Str("db_path", cfg.DBPath).
			Str("data_path", dataPath).
			Msg("server listening")
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			zlog.Fatal().Err(err).Msg("server failed")
		}
	}()

	// ---------- Graceful shutdown ----------
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	zlog.Info().Msg("shutdown signal received")
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		zlog.Error().Err(err).Msg("server shutdown error")
	} else {
		zlog.Info().Msg("server shutdown complete")
	}
}
