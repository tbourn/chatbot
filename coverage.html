
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tbourn/go-chat-backend/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/tbourn/go-chat-backend/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/tbourn/go-chat-backend/internal/config/config.go (100.0%)</option>
				
				<option value="file3">github.com/tbourn/go-chat-backend/internal/domain/idempotency.go (100.0%)</option>
				
				<option value="file4">github.com/tbourn/go-chat-backend/internal/domain/models.go (100.0%)</option>
				
				<option value="file5">github.com/tbourn/go-chat-backend/internal/http/handlers/chat_handler.go (100.0%)</option>
				
				<option value="file6">github.com/tbourn/go-chat-backend/internal/http/handlers/feedback_handler.go (100.0%)</option>
				
				<option value="file7">github.com/tbourn/go-chat-backend/internal/http/handlers/message_handler.go (100.0%)</option>
				
				<option value="file8">github.com/tbourn/go-chat-backend/internal/http/handlers/response.go (100.0%)</option>
				
				<option value="file9">github.com/tbourn/go-chat-backend/internal/http/middleware/idempotency.go (100.0%)</option>
				
				<option value="file10">github.com/tbourn/go-chat-backend/internal/http/middleware/logging.go (100.0%)</option>
				
				<option value="file11">github.com/tbourn/go-chat-backend/internal/http/middleware/metrics.go (100.0%)</option>
				
				<option value="file12">github.com/tbourn/go-chat-backend/internal/http/middleware/ratelimit.go (100.0%)</option>
				
				<option value="file13">github.com/tbourn/go-chat-backend/internal/http/middleware/redact_logger.go (100.0%)</option>
				
				<option value="file14">github.com/tbourn/go-chat-backend/internal/http/middleware/security.go (100.0%)</option>
				
				<option value="file15">github.com/tbourn/go-chat-backend/internal/http/router.go (98.4%)</option>
				
				<option value="file16">github.com/tbourn/go-chat-backend/internal/observability/otel.go (100.0%)</option>
				
				<option value="file17">github.com/tbourn/go-chat-backend/internal/repo/chat_repo.go (100.0%)</option>
				
				<option value="file18">github.com/tbourn/go-chat-backend/internal/repo/db.go (94.1%)</option>
				
				<option value="file19">github.com/tbourn/go-chat-backend/internal/repo/feedback_repo.go (100.0%)</option>
				
				<option value="file20">github.com/tbourn/go-chat-backend/internal/repo/idempotency.go (100.0%)</option>
				
				<option value="file21">github.com/tbourn/go-chat-backend/internal/repo/message_repo.go (100.0%)</option>
				
				<option value="file22">github.com/tbourn/go-chat-backend/internal/repo/stats.go (100.0%)</option>
				
				<option value="file23">github.com/tbourn/go-chat-backend/internal/search/index.go (97.7%)</option>
				
				<option value="file24">github.com/tbourn/go-chat-backend/internal/search/preprocess.go (98.3%)</option>
				
				<option value="file25">github.com/tbourn/go-chat-backend/internal/services/chat_service.go (100.0%)</option>
				
				<option value="file26">github.com/tbourn/go-chat-backend/internal/services/feedback_service.go (100.0%)</option>
				
				<option value="file27">github.com/tbourn/go-chat-backend/internal/services/message_service.go (95.0%)</option>
				
				<option value="file28">github.com/tbourn/go-chat-backend/internal/sysutil/sysutil.go (100.0%)</option>
				
				<option value="file29">github.com/tbourn/go-chat-backend/internal/utils/pagination.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Command go-chat-backend is the main entrypoint for the Chat Backend API.
//
// This service provides a REST API for chat-based Q&amp;A on market research data,
// exposing endpoints under /api/v*. It is designed as a production-ready,
// observable microservice with the following key features:
//
//   - Gin framework with middleware for compression, tracing, and request context.
//   - SQLite persistence via GORM (with optional auto-migration in dev).
//   - Pluggable semantic search index built from Markdown datasets.
//   - OpenTelemetry instrumentation for traces and metrics.
//   - Structured JSON logging via zerolog (with console pretty mode).
//   - Graceful shutdown on SIGINT/SIGTERM with configurable timeouts.
//   - Optional Swagger UI for API exploration.
//
// Configuration is sourced from environment variables and a config file
// (see internal/config). Build metadata (version, commit, date) is injected
// at compile time using -ldflags.
//
// Example:
//
//        LOG_LEVEL=debug DATA_MD=./data/data.md ./go-chat-backend
//
// For schema and endpoint documentation, see the generated Swagger spec
// under /swagger when enabled.
package main

import (
        "bytes"
        "context"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/joho/godotenv"

        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog"
        zlog "github.com/rs/zerolog/log"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "gorm.io/plugin/opentelemetry/tracing"

        "github.com/tbourn/go-chat-backend/internal/config"
        httpapi "github.com/tbourn/go-chat-backend/internal/http"
        "github.com/tbourn/go-chat-backend/internal/observability"
        "github.com/tbourn/go-chat-backend/internal/repo"
        "github.com/tbourn/go-chat-backend/internal/search"
        "github.com/tbourn/go-chat-backend/internal/sysutil"

        // swagger docs (generated by `swag init`)
        _ "github.com/tbourn/go-chat-backend/docs"
)

// Populated via -ldflags at build time (see Dockerfile)
var (
        version = "dev"
        commit  = "unknown"
        date    = "unknown"
)

// @title           Go Chat Backend API
// @version         1.0.0
// @description     Public REST API for chat-based Q&amp;A over market research data.
//
// @contact.name    Thomas Bournaveas
// @contact.url     https://thomasbournaveas.com
// @contact.email   thomas.bournaveas@gmail.com
//
// @license.name    MIT
// @license.url     https://opensource.org/licenses/MIT
//
// @BasePath        /api/v1
// @schemes         http
// @accept          json
// @produce         json
//
// @tag.name        Chats
// @tag.description Manage chat sessions and messages
//
// @tag.name        Feedback
// @tag.description Submit feedback on assistant messages
//
// @tag.name        Messages
// @tag.description Send messages and get assistant replies
//
// @externalDocs.description Project documentation
// @externalDocs.url         https://github.com/tbourn/go-chat-backend
func main() <span class="cov0" title="0">{
        // Load .env files (non-fatal). Precedence: process env &gt; .env.local &gt; .env
        _ = godotenv.Load(".env")
        _ = godotenv.Overload(".env.local")

        // ---------- Config ----------
        cfg := config.MustLoad() // single source of truth

        // ---------- Logging ----------
        zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
        sysutil.SetLogLevel(cfg.LogLevel)
        if cfg.LogPretty </span><span class="cov0" title="0">{
                zlog.Logger = zlog.Output(zerolog.ConsoleWriter{Out: os.Stdout})
        }</span> else<span class="cov0" title="0"> {
                zlog.Logger = zerolog.New(os.Stdout).With().Timestamp().Logger()
        }</span>

        // ---------- Gin mode ----------
        <span class="cov0" title="0">switch strings.ToLower(cfg.GinMode) </span>{ // require GinMode in config
        case "debug":<span class="cov0" title="0">
                gin.SetMode(gin.DebugMode)</span>
        case "test":<span class="cov0" title="0">
                gin.SetMode(gin.TestMode)</span>
        default:<span class="cov0" title="0">
                gin.SetMode(gin.ReleaseMode)</span>
        }

        // ---------- OpenTelemetry (tracing) ----------
        <span class="cov0" title="0">otelShutdown, err := observability.SetupOTel(context.Background(), cfg.OTEL, version)
        if err != nil </span><span class="cov0" title="0">{
                zlog.Fatal().Err(err).Msg("otel setup failed")
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                _ = otelShutdown(ctx)
        }</span>()

        // ---------- Database ----------
        <span class="cov0" title="0">db, err := repo.OpenSQLite(cfg.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                zlog.Fatal().Err(err).Str("db_path", cfg.DBPath).Msg("db open failed")
        }</span>
        <span class="cov0" title="0">if sqlDB, e := db.DB(); e == nil </span><span class="cov0" title="0">{
                defer sqlDB.Close()
        }</span>
        <span class="cov0" title="0">if err := db.Use(tracing.NewPlugin()); err != nil </span><span class="cov0" title="0">{
                zlog.Warn().Err(err).Msg("gorm otel plugin failed")
        }</span>
        <span class="cov0" title="0">if err := repo.AutoMigrate(db); err != nil </span><span class="cov0" title="0">{
                zlog.Fatal().Err(err).Msg("db migration failed")
        }</span>

        // ---------- Search index (from data.md) ----------
        // Prefer cfg.DataMD override, then cfg.DataPath, then sensible default.
        <span class="cov0" title="0">dataPath := sysutil.FirstNonEmpty(cfg.DataMD, cfg.DataPath, "data/data.md")
        mdBytes, prepErr := search.PrepareMarkdownInMemory(dataPath)
        if prepErr != nil </span><span class="cov0" title="0">{
                zlog.Warn().Err(prepErr).Str("data_path", dataPath).
                        Msg("markdown preprocess failed; indexing raw file")
                if raw, readErr := os.ReadFile(dataPath); readErr == nil </span><span class="cov0" title="0">{
                        mdBytes = raw
                }</span> else<span class="cov0" title="0"> {
                        mdBytes = []byte{}
                }</span>
        }
        <span class="cov0" title="0">idx, idxErr := search.NewIndexFromReader(
                bytes.NewReader(mdBytes),
                search.WithMinParagraphRunes(1),
        )
        if idxErr != nil </span><span class="cov0" title="0">{
                zlog.Warn().Err(idxErr).Str("data_path", dataPath).
                        Msg("index build encountered an error; bot may decline more often")
        }</span>

        // Similarity threshold: keep permissive default for recall if unset
        <span class="cov0" title="0">if cfg.Threshold &lt;= 0 </span><span class="cov0" title="0">{
                cfg.Threshold = 0.10
        }</span>

        // ---------- Router &amp; middleware ----------
        <span class="cov0" title="0">r := gin.New()
        r.Use(gzip.Gzip(gzip.DefaultCompression))

        // Simple user identity stub
        r.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                uid := strings.TrimSpace(c.GetHeader("X-User-ID"))
                if uid == "" </span><span class="cov0" title="0">{
                        uid = "demo-user"
                }</span>
                <span class="cov0" title="0">c.Set("userID", uid)
                c.Next()</span>
        })

        // Wire routes (otel, metrics, cors, security, api, etc. are set inside)
        <span class="cov0" title="0">httpapi.RegisterRoutes(r, db, idx, cfg)

        // Swagger UI (opt-in)
        if cfg.SwaggerEnabled </span><span class="cov0" title="0">{
                r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        }</span>

        // ---------- HTTP server ----------
        <span class="cov0" title="0">addr := ":" + cfg.Port
        srv := &amp;http.Server{
                Addr:              addr,
                Handler:           r,
                ReadTimeout:       cfg.ReadTimeout,
                ReadHeaderTimeout: cfg.ReadHeaderTimeout,
                WriteTimeout:      cfg.WriteTimeout,
                IdleTimeout:       cfg.IdleTimeout,
                MaxHeaderBytes:    cfg.MaxHeaderBytes,
        }

        // Start
        go func() </span><span class="cov0" title="0">{
                zlog.Info().
                        Str("addr", addr).
                        Str("version", version).
                        Str("commit", commit).
                        Str("date", date).
                        Str("db_path", cfg.DBPath).
                        Str("data_path", dataPath).
                        Msg("server listening")
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        zlog.Fatal().Err(err).Msg("server failed")
                }</span>
        }()

        // ---------- Graceful shutdown ----------
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        zlog.Info().Msg("shutdown signal received")
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                zlog.Error().Err(err).Msg("server shutdown error")
        }</span> else<span class="cov0" title="0"> {
                zlog.Info().Msg("server shutdown complete")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Thomas Bournaveas",
            "url": "https://thomasbournaveas.com",
            "email": "thomas.bournaveas@gmail.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/chats": {
            "get": {
                "description": "Returns a page of the user's chats. Supports weak ETag via If-None-Match and may return 304.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chats"
                ],
                "summary": "List chats (paginated)",
                "operationId": "listChats",
                "parameters": [
                    {
                        "type": "string",
                        "example": "user123",
                        "description": "User ID (demo header)",
                        "name": "X-User-ID",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "example": "W/\\\"abc123\\\"",
                        "description": "Return 304 if ETag matches",
                        "name": "If-None-Match",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "maximum": 100,
                        "minimum": 1,
                        "type": "integer",
                        "default": 20,
                        "description": "Items per page",
                        "name": "page_size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ListChatsResponse"
                        },
                        "headers": {
                            "Cache-Control": {
                                "type": "string",
                                "description": "Caching directives (if set)"
                            },
                            "ETag": {
                                "type": "string",
                                "description": "Weak ETag for current result"
                            }
                        }
                    },
                    "304": {
                        "description": "Not Modified",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal error",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a chat for the current user and returns the chat resource.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chats"
                ],
                "summary": "Create a new chat",
                "operationId": "createChat",
                "parameters": [
                    {
                        "description": "Create chat payload",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.CreateChatRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_tbourn_go-chat-backend_internal_domain.Chat"
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal error",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/chats/{id}/messages": {
            "get": {
                "description": "Returns a paginated list of messages for the given chat.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Messages"
                ],
                "summary": "List messages in a chat",
                "operationId": "listMessages",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Chat ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "maximum": 100,
                        "minimum": 1,
                        "type": "integer",
                        "default": 20,
                        "description": "Items per page",
                        "name": "page_size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ListMessagesResponse"
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Chat not found",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal error",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Appends a user message to the chat and generates an assistant reply.\nSupports idempotency via the Idempotency-Key header (same key → same result).",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Messages"
                ],
                "summary": "Send a message and get assistant reply",
                "operationId": "postMessage",
                "parameters": [
                    {
                        "type": "string",
                        "example": "user123",
                        "description": "User ID that owns the chat",
                        "name": "X-User-ID",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "7a8d9f4c-1b2a-4c3d-8e9f-0123456789ab",
                        "description": "Idempotency key for safe retries (UUID recommended)",
                        "name": "Idempotency-Key",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Chat ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "User message payload",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.PostMessageRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Assistant reply",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.PostMessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Chat not found",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal error",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/chats/{id}/title": {
            "put": {
                "description": "Updates the title of a chat owned by the current user.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chats"
                ],
                "summary": "Rename a chat",
                "operationId": "updateChatTitle",
                "parameters": [
                    {
                        "type": "string",
                        "example": "user123",
                        "description": "User ID (demo header)",
                        "name": "X-User-ID",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "format": "uuid",
                        "example": "141add05-4415-4938-b5a1-17e0d3171aff",
                        "description": "Chat ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "New title",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.UpdateChatTitleRequest"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Chat not found",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal error",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/messages/{id}/feedback": {
            "post": {
                "description": "Records positive (+1) or negative (-1) feedback for an assistant message.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Feedback"
                ],
                "summary": "Leave feedback on a message",
                "operationId": "leaveFeedback",
                "parameters": [
                    {
                        "type": "string",
                        "example": "user123",
                        "description": "User ID (demo header)",
                        "name": "X-User-ID",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "format": "uuid",
                        "example": "fa4dfbe0-c3bf-47bd-b32f-d7de221cf43b",
                        "description": "Message ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Feedback payload",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.LeaveFeedbackRequest"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Not allowed to leave feedback",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Message not found",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Feedback already exists",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_http_handlers.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_tbourn_go-chat-backend_internal_domain.Chat": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "string"
                }
            }
        },
        "github_com_tbourn_go-chat-backend_internal_domain.Message": {
            "type": "object",
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "score": {
                    "description": "only for assistant messages",
                    "type": "number"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "internal_http_handlers.CreateChatRequest": {
            "type": "object",
            "properties": {
                "title": {
                    "description": "Title optionally sets the chat title; a default is used when empty.",
                    "type": "string",
                    "example": "Customer insights UK"
                }
            }
        },
        "internal_http_handlers.ErrorResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "description": "Stable, machine-readable code (see errors.go constants)",
                    "type": "string",
                    "example": "not_found"
                },
                "message": {
                    "description": "Human-readable message (safe to show to users)",
                    "type": "string",
                    "example": "resource not found"
                },
                "request_id": {
                    "description": "Correlates server logs and client errors",
                    "type": "string",
                    "example": "123e4567-e89b-12d3-a456-426614174000"
                }
            }
        },
        "internal_http_handlers.LeaveFeedbackRequest": {
            "type": "object",
            "required": [
                "value"
            ],
            "properties": {
                "comment": {
                    "type": "string",
                    "example": "Looks good"
                },
                "value": {
                    "description": "Value is the feedback signal: +1 (positive) or -1 (negative).",
                    "type": "integer",
                    "enum": [
                        -1,
                        1
                    ],
                    "example": 1
                }
            }
        },
        "internal_http_handlers.ListChatsResponse": {
            "type": "object",
            "properties": {
                "chats": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_tbourn_go-chat-backend_internal_domain.Chat"
                    }
                },
                "pagination": {
                    "$ref": "#/definitions/internal_http_handlers.Pagination"
                }
            }
        },
        "internal_http_handlers.ListMessagesResponse": {
            "type": "object",
            "properties": {
                "messages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_tbourn_go-chat-backend_internal_domain.Message"
                    }
                },
                "pagination": {
                    "$ref": "#/definitions/internal_http_handlers.Pagination"
                }
            }
        },
        "internal_http_handlers.Pagination": {
            "type": "object",
            "properties": {
                "has_next": {
                    "type": "boolean"
                },
                "page": {
                    "type": "integer"
                },
                "page_size": {
                    "type": "integer"
                },
                "total": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "internal_http_handlers.PostMessageRequest": {
            "type": "object",
            "required": [
                "content"
            ],
            "properties": {
                "content": {
                    "description": "Content is the user prompt. It must be non-empty.",
                    "type": "string",
                    "minLength": 1,
                    "example": "What percentage of Gen Z in Nashville discover new brands through podcasts?"
                }
            }
        },
        "internal_http_handlers.PostMessageResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "description": "Message is the assistant reply created as a result of the request.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/github_com_tbourn_go-chat-backend_internal_domain.Message"
                        }
                    ]
                }
            }
        },
        "internal_http_handlers.UpdateChatTitleRequest": {
            "type": "object",
            "required": [
                "title"
            ],
            "properties": {
                "title": {
                    "description": "Title is the new chat name (1–255 chars).",
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 1,
                    "example": "Penetration - 18–24 UK"
                }
            }
        }
    },
    "tags": [
        {
            "description": "Manage chat sessions and messages",
            "name": "Chats"
        },
        {
            "description": "Submit feedback on assistant messages",
            "name": "Feedback"
        },
        {
            "description": "Send messages and get assistant replies",
            "name": "Messages"
        }
    ],
    "externalDocs": {
        "description": "Project documentation",
        "url": "https://github.com/tbourn/go-chat-backend"
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "",
        BasePath:         "/api/v1",
        Schemes:          []string{"http"},
        Title:            "Go Chat Backend API",
        Description:      "Public REST API for chat-based Q&amp;A over market research data.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package config provides application configuration loaded from environment
// variables with defaults and validation. It centralizes application settings
// such as server timeouts, logging, database paths, rate limiting, and observability.
package config

import (
        "errors"
        "os"
        "strconv"
        "strings"
        "time"
)

// CORSConfig defines Cross-Origin Resource Sharing settings.
type CORSConfig struct {
        AllowedOrigins []string
}

// SecurityConfig defines security-related settings such as HSTS.
type SecurityConfig struct {
        EnableHSTS bool
        HSTSMaxAge time.Duration
}

// OTELConfig defines OpenTelemetry observability settings.
type OTELConfig struct {
        Enabled     bool    // OTEL_ENABLED
        Endpoint    string  // OTEL_EXPORTER_OTLP_ENDPOINT (e.g. "otel:4317")
        Insecure    bool    // OTEL_EXPORTER_OTLP_INSECURE (true if no TLS)
        ServiceName string  // OTEL_SERVICE_NAME (e.g. "go-chat-backend")
        SampleRatio float64 // OTEL_TRACES_SAMPLER_ARG in [0..1]
}

// Config holds all configuration values for the application.
type Config struct {
        // Server
        Port              string        // just the number
        ReadTimeout       time.Duration // e.g. 15s
        ReadHeaderTimeout time.Duration // e.g. 10s
        WriteTimeout      time.Duration // e.g. 20s
        IdleTimeout       time.Duration // e.g. 60s
        MaxHeaderBytes    int           // bytes
        GinMode           string        // debug|release|test

        // Logging / Docs
        LogLevel       string // debug|info|warn|error|fatal|panic
        LogPretty      bool   // pretty console logs in dev
        SwaggerEnabled bool   // enable Swagger UI route
        APIBasePath    string // base path for API routes

        // App
        DBPath    string  // SQLite path
        DataPath  string  // default path to data.md
        DataMD    string  // optional override for DataPath
        Threshold float64 // retrieval confidence threshold [0,1]

        // Rate limiting
        RateRPS   float64 // tokens per second (&gt;= 0)
        RateBurst int     // bucket size (&gt;= 1)

        // Web protection
        CORS     CORSConfig
        Security SecurityConfig

        // Idempotency
        IdempotencyTTL time.Duration // how long a given Idempotency-Key is valid

        // Observability
        OTEL OTELConfig
}

// MustLoad loads the configuration and panics if validation fails.
func MustLoad() Config <span class="cov2" title="2">{
        cfg, err := Load()
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov1" title="1">return cfg</span>
}

// Load reads configuration from environment variables,
// applies defaults, normalizes values, and validates the result.
func Load() (Config, error) <span class="cov5" title="16">{
        cfg := Config{
                // Server
                Port:              getenv("PORT", "8080"),
                ReadTimeout:       getdur("READ_TIMEOUT", 15*time.Second),
                ReadHeaderTimeout: getdur("READ_HEADER_TIMEOUT", 10*time.Second),
                WriteTimeout:      getdur("WRITE_TIMEOUT", 20*time.Second),
                IdleTimeout:       getdur("IDLE_TIMEOUT", 60*time.Second),
                MaxHeaderBytes:    getint("MAX_HEADER_BYTES", 1&lt;&lt;20),
                GinMode:           strings.ToLower(getenv("GIN_MODE", "release")),

                // Logging / Docs
                LogLevel:       strings.ToLower(getenv("LOG_LEVEL", "info")),
                LogPretty:      getbool("LOG_PRETTY", false),
                SwaggerEnabled: getbool("SWAGGER_ENABLED", false),
                APIBasePath:    normalizeBasePath(getenv("API_BASE_PATH", "/api/v1")),

                // App
                DBPath:    getenv("DB_PATH", "app.db"),
                DataPath:  getenv("DATA_PATH", "data/data.md"),
                DataMD:    getenv("DATA_MD", ""),
                Threshold: getfloat("THRESHOLD", 0.32),

                // Rate limiting
                RateRPS:   getfloat("RATE_RPS", 5.0),
                RateBurst: getint("RATE_BURST", 10),

                // Web protection
                CORS: CORSConfig{
                        AllowedOrigins: splitCSV(getenv("CORS_ALLOWED_ORIGINS", "")),
                },
                Security: SecurityConfig{
                        EnableHSTS: getbool("ENABLE_HSTS", false),
                        HSTSMaxAge: getdur("HSTS_MAX_AGE", 180*24*time.Hour),
                },

                // Idempotency
                IdempotencyTTL: getdur("IDEMPOTENCY_TTL", 24*time.Hour),

                // Observability (OpenTelemetry)
                OTEL: OTELConfig{
                        Enabled:     getbool("OTEL_ENABLED", false),
                        Endpoint:    getenv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317"),
                        Insecure:    getbool("OTEL_EXPORTER_OTLP_INSECURE", true),
                        ServiceName: getenv("OTEL_SERVICE_NAME", "go-chat-backend"),
                        SampleRatio: getfloat("OTEL_TRACES_SAMPLER_ARG", 1.0),
                },
        }

        // --- normalization ---
        if cfg.LogLevel == "warning" </span><span class="cov1" title="1">{
                cfg.LogLevel = "warn"
        }</span>
        <span class="cov5" title="16">switch cfg.GinMode </span>{
        case "debug", "release", "test":<span class="cov5" title="15"></span>
        default:<span class="cov1" title="1">
                cfg.GinMode = "release"</span>
        }

        // --- validation ---
        <span class="cov5" title="16">switch cfg.LogLevel </span>{
        case "debug", "info", "warn", "error", "fatal", "panic":<span class="cov5" title="14"></span>
        default:<span class="cov2" title="2">
                return cfg, errors.New("LOG_LEVEL must be one of: debug, info, warn, error, fatal, panic")</span>
        }
        <span class="cov5" title="14">if strings.TrimSpace(cfg.Port) == "" </span><span class="cov1" title="1">{
                return cfg, errors.New("PORT must not be empty")
        }</span>
        <span class="cov5" title="13">if cfg.ReadTimeout &lt;= 0 || cfg.ReadHeaderTimeout &lt;= 0 || cfg.WriteTimeout &lt;= 0 || cfg.IdleTimeout &lt;= 0 </span><span class="cov1" title="1">{
                return cfg, errors.New("timeouts must be positive durations")
        }</span>
        <span class="cov5" title="12">if cfg.MaxHeaderBytes &lt;= 0 </span><span class="cov1" title="1">{
                return cfg, errors.New("MAX_HEADER_BYTES must be &gt; 0")
        }</span>
        <span class="cov5" title="11">if strings.TrimSpace(cfg.DBPath) == "" </span><span class="cov1" title="1">{
                return cfg, errors.New("DB_PATH must not be empty")
        }</span>
        <span class="cov5" title="10">if strings.TrimSpace(cfg.DataPath) == "" </span><span class="cov1" title="1">{
                return cfg, errors.New("DATA_PATH must not be empty")
        }</span>
        <span class="cov4" title="9">if cfg.Threshold &lt; 0 || cfg.Threshold &gt; 1 </span><span class="cov1" title="1">{
                return cfg, errors.New("THRESHOLD must be between 0 and 1")
        }</span>
        <span class="cov4" title="8">if cfg.RateRPS &lt; 0 </span><span class="cov1" title="1">{
                return cfg, errors.New("RATE_RPS must be &gt;= 0")
        }</span>
        <span class="cov4" title="7">if cfg.RateBurst &lt; 1 </span><span class="cov1" title="1">{
                return cfg, errors.New("RATE_BURST must be &gt;= 1")
        }</span>
        <span class="cov4" title="6">if cfg.Security.HSTSMaxAge &lt; 0 </span><span class="cov1" title="1">{
                return cfg, errors.New("HSTS_MAX_AGE must be &gt;= 0")
        }</span>
        <span class="cov3" title="5">if cfg.IdempotencyTTL &lt;= 0 </span><span class="cov1" title="1">{
                return cfg, errors.New("IDEMPOTENCY_TTL must be &gt; 0")
        }</span>
        <span class="cov3" title="4">if cfg.OTEL.SampleRatio &lt; 0 || cfg.OTEL.SampleRatio &gt; 1 </span><span class="cov1" title="1">{
                return cfg, errors.New("OTEL_TRACES_SAMPLER_ARG must be in [0,1]")
        }</span>
        // if cfg.APIBasePath == "" || cfg.APIBasePath[0] != '/' {
        //         return cfg, errors.New("API_BASE_PATH must start with '/'")
        // }

        <span class="cov2" title="3">return cfg, nil</span>
}

// ---- helpers (no external deps) ----

func getenv(k, def string) string <span class="cov10" title="162">{
        if v, ok := os.LookupEnv(k); ok &amp;&amp; v != "" </span><span class="cov6" title="18">{
                return v
        }</span>
        <span class="cov9" title="144">return def</span>
}

func getfloat(k string, def float64) float64 <span class="cov7" title="50">{
        if v, ok := os.LookupEnv(k); ok &amp;&amp; v != "" </span><span class="cov4" title="8">{
                if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov4" title="6">{
                        return f
                }</span>
        }
        <span class="cov7" title="44">return def</span>
}

func getint(k string, def int) int <span class="cov7" title="34">{
        if v, ok := os.LookupEnv(k); ok &amp;&amp; v != "" </span><span class="cov4" title="6">{
                if i, err := strconv.Atoi(v); err == nil </span><span class="cov3" title="4">{
                        return i
                }</span>
        }
        <span class="cov7" title="30">return def</span>
}

func getbool(k string, def bool) bool <span class="cov9" title="96">{
        if v, ok := os.LookupEnv(k); ok &amp;&amp; v != "" </span><span class="cov6" title="19">{
                switch strings.ToLower(strings.TrimSpace(v)) </span>{
                case "1", "true", "yes", "y", "on":<span class="cov5" title="11">
                        return true</span>
                case "0", "false", "no", "n", "off":<span class="cov4" title="8">
                        return false</span>
                }
        }
        <span class="cov8" title="77">return def</span>
}

func getdur(k string, def time.Duration) time.Duration <span class="cov9" title="98">{
        if v, ok := os.LookupEnv(k); ok &amp;&amp; v != "" </span><span class="cov5" title="11">{
                if d, err := time.ParseDuration(v); err == nil </span><span class="cov5" title="10">{
                        return d
                }</span>
        }
        <span class="cov8" title="88">return def</span>
}

func splitCSV(s string) []string <span class="cov6" title="18">{
        if s == "" </span><span class="cov5" title="16">{
                return nil
        }</span>
        <span class="cov2" title="2">parts := strings.Split(s, ",")
        out := make([]string, 0, len(parts))
        for _, p := range parts </span><span class="cov4" title="8">{
                t := strings.TrimSpace(p)
                if t != "" </span><span class="cov3" title="5">{
                        out = append(out, t)
                }</span>
        }
        <span class="cov2" title="2">return out</span>
}

// normalizeBasePath ensures leading '/' and strips trailing '/' (except root).
func normalizeBasePath(p string) string <span class="cov6" title="20">{
        p = strings.TrimSpace(p)
        if p == "" </span><span class="cov1" title="1">{
                return "/"
        }</span>
        <span class="cov6" title="19">if !strings.HasPrefix(p, "/") </span><span class="cov2" title="2">{
                p = "/" + p
        }</span>
        <span class="cov6" title="19">if len(p) &gt; 1 &amp;&amp; strings.HasSuffix(p, "/") </span><span class="cov2" title="2">{
                p = strings.TrimRight(p, "/")
        }</span>
        <span class="cov6" title="19">return p</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package domain defines the core persistence models for the application.
// These types are used by GORM for database schema mapping and are shared
// across the repository and service layers.
package domain

import "time"

// Idempotency represents a recorded result of a previously processed request,
// keyed by (user_id, chat_id, key). It enables safe retries for POST/PUT
// operations by returning the originally produced response without re-executing
// side effects.
type Idempotency struct {
        ID        string    `gorm:"type:TEXT NOT NULL;primaryKey"`
        UserID    string    `gorm:"type:TEXT NOT NULL;uniqueIndex:ux_user_chat_key,priority:1"`
        ChatID    string    `gorm:"type:TEXT NOT NULL;uniqueIndex:ux_user_chat_key,priority:2"`
        Key       string    `gorm:"type:TEXT NOT NULL;uniqueIndex:ux_user_chat_key,priority:3"`
        MessageID string    `gorm:"type:TEXT NOT NULL"`
        Status    int       `gorm:"type:INTEGER NOT NULL"`
        CreatedAt time.Time `gorm:"type:DATETIME NOT NULL;autoCreateTime"`
        ExpiresAt time.Time `gorm:"type:DATETIME NOT NULL;index"`
}

// TableName implements the GORM tabler interface.
func (Idempotency) TableName() string <span class="cov10" title="19">{ return "idempotency" }</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package domain defines the persistence models for chats, messages, and
// feedback. These types are mapped with GORM and form the core data layer
// of the chatbot application.
package domain

import (
        "time"

        "gorm.io/gorm"
)

// Chat represents a conversation owned by a user. Each chat has a generated
// title and contains one or more messages exchanged between the user and
// the assistant.
//
// Fields:
//   - ID: stable UUID primary key (char(36)).
//   - UserID: identifier of the chat owner; indexed for efficient retrieval.
//   - Title: human-readable chat title (auto-generated if not provided).
//   - CreatedAt / UpdatedAt: timestamps managed by GORM.
//   - DeletedAt: soft deletion marker (retains row for audit/history).
type Chat struct {
        ID        string         `json:"id"        gorm:"type:char(36);primaryKey"`
        UserID    string         `json:"user_id"   gorm:"type:varchar(64);not null;index:idx_user_chats"`
        Title     string         `json:"title"     gorm:"type:varchar(255);not null;default:'New chat'"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"-"         gorm:"index"`
}

// TableName returns the database table name for Chat.
func (Chat) TableName() string <span class="cov10" title="62">{ return "chats" }</span>

// Message represents a single utterance within a chat. Messages are linked
// to a chat, and can be authored either by the "user" or the "assistant".
// Assistant messages may include a confidence score.
//
// Fields:
//   - ID: UUID primary key (char(36)).
//   - ChatID: foreign key to the owning chat (indexed).
//   - Role: "user" or "assistant" (enforced by DB constraint).
//   - Content: full text content of the message.
//   - Score: optional numeric score (only present for assistant messages).
//   - CreatedAt / UpdatedAt: timestamps managed by GORM.
//   - DeletedAt: soft deletion marker.
//   - Chat: FK association, ensures cascade delete/update.
type Message struct {
        ID        string         `json:"id"        gorm:"type:char(36);primaryKey"`
        ChatID    string         `json:"chat_id"   gorm:"type:char(36);not null;index:idx_chat_msgs,priority:1"`
        Role      string         `json:"role"      gorm:"type:varchar(16);not null;check:role IN ('user','assistant')"`
        Content   string         `json:"content"   gorm:"type:text;not null"`
        Score     *float64       `json:"score,omitempty"` // only for assistant messages
        CreatedAt time.Time      `json:"created_at" gorm:"index:idx_chat_msgs,priority:2"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"-"         gorm:"index"`

        // Chat is the parent conversation. Messages are cascade-deleted
        // if their chat is removed.
        Chat Chat `json:"-" gorm:"foreignKey:ChatID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

// TableName returns the database table name for Message.
func (Message) TableName() string <span class="cov9" title="47">{ return "messages" }</span>

// Feedback represents a user-provided rating on a specific assistant message.
// A user can only leave one feedback entry per message (enforced by unique index).
//
// Fields:
//   - ID: UUID primary key (char(36)).
//   - MessageID: foreign key to the rated message (unique per user).
//   - UserID: identifier of the feedback author (unique per message).
//   - Value: +1 (positive) or -1 (negative).
//   - CreatedAt / UpdatedAt: timestamps managed by GORM.
//   - DeletedAt: soft deletion marker.
//   - Message: FK association, ensures cascade delete/update.
type Feedback struct {
        ID        string         `json:"id"         gorm:"type:char(36);primaryKey"`
        MessageID string         `json:"message_id" gorm:"type:char(36);not null;index;uniqueIndex:ux_feedback_message_user"`
        UserID    string         `json:"user_id"    gorm:"type:varchar(64);not null;index;uniqueIndex:ux_feedback_message_user"`
        Value     int            `json:"value"      gorm:"not null;check:value IN (-1,1)"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"-"          gorm:"index"`

        // Message is the rated assistant message. Feedback is cascade-deleted
        // if the underlying message is removed.
        Message Message `json:"-" gorm:"foreignKey:MessageID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

// TableName returns the database table name for Feedback.
func (Feedback) TableName() string <span class="cov8" title="29">{ return "feedback" }</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Chat HTTP handlers.
//
// This file exposes REST endpoints for chat resources:
//   - POST   /chats               (create)
//   - GET    /chats               (list, paginated, ETag support)
//   - PUT    /chats/{id}/title    (rename)
//
// Handlers are transport-thin: they validate input, call application services,
// and translate results into HTTP responses (including conditional responses).
package handlers

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
        "github.com/tbourn/go-chat-backend/internal/repo"
        "github.com/tbourn/go-chat-backend/internal/services"
        "github.com/tbourn/go-chat-backend/internal/utils"
)

//
// Service contracts (context-aware)
//

// ChatService defines chat lifecycle operations consumed by HTTP handlers.
//
// Implementations should be safe for concurrent use and must honor the
// provided context for cancellation and timeouts.
type ChatService interface {
        // Create starts a new chat for userID with an optional title.
        Create(ctx context.Context, userID, title string) (*domain.Chat, error)
        // List returns all chats for a user (legacy, non-paginated).
        List(ctx context.Context, userID string) ([]domain.Chat, error)
        // ListPage returns a page of chats for a user and the total count.
        ListPage(ctx context.Context, userID string, page, pageSize int) ([]domain.Chat, int64, error)
        // UpdateTitle renames a chat that belongs to userID.
        UpdateTitle(ctx context.Context, userID, chatID, title string) error
}

// MessageService defines message retrieval and generation operations.
//
// Implementations should be safe for concurrent use and must honor the
// provided context for cancellation and timeouts.
type MessageService interface {
        // Answer appends a user prompt and an assistant reply to a chat atomically.
        Answer(ctx context.Context, userID, chatID, prompt string) (*domain.Message, error)
        // ListPage returns a page of messages within a chat and the total count.
        ListPage(ctx context.Context, chatID string, page, pageSize int) ([]domain.Message, int64, error)
}

// FeedbackService defines operations to capture user feedback on messages.
//
// Implementations should be safe for concurrent use and must honor the
// provided context for cancellation and timeouts.
type FeedbackService interface {
        // Leave submits a feedback value (-1 or 1) for messageID by userID.
        Leave(ctx context.Context, userID, messageID string, value int) error
}

//
// Handler wiring
//

// Handlers groups HTTP endpoints for chats, messages, and feedback.
// It depends on abstract service interfaces to keep transport concerns
// separate from business logic.
type Handlers struct {
        chatSvc ChatService
        msgSvc  MessageService
        fbSvc   FeedbackService
}

// New constructs and returns a Handlers instance bound to the given services.
func New(chatSvc ChatService, msgSvc MessageService, fbSvc FeedbackService) *Handlers <span class="cov10" title="34">{
        return &amp;Handlers{chatSvc: chatSvc, msgSvc: msgSvc, fbSvc: fbSvc}
}</span>

// userID extracts the authenticated user id from Gin context (set by upstream
// middleware). If absent, it falls back to "X-User-ID" header (tests use it),
// and finally to "demo-user". It never touches c.Request if it's nil.
func userID(c *gin.Context) string <span class="cov9" title="24">{
        if v, ok := c.Get("userID"); ok </span><span class="cov2" title="2">{
                if s, ok := v.(string); ok &amp;&amp; s != "" </span><span class="cov1" title="1">{
                        return s
                }</span>
        }
        <span class="cov9" title="23">if c != nil &amp;&amp; c.Request != nil </span><span class="cov8" title="21">{
                if h := strings.TrimSpace(c.GetHeader("X-User-ID")); h != "" </span><span class="cov8" title="17">{
                        return h
                }</span>
        }
        <span class="cov5" title="6">return "demo-user"</span>
}

//
// DTOs
//

// CreateChatRequest is the JSON payload for creating a chat.
type CreateChatRequest struct {
        // Title optionally sets the chat title; a default is used when empty.
        Title string `json:"title" example:"Customer insights UK"`
}

// UpdateChatTitleRequest is the JSON payload for updating a chat title.
type UpdateChatTitleRequest struct {
        // Title is the new chat name (1–255 chars).
        Title string `json:"title" binding:"required,min=1,max=255" example:"Penetration - 18–24 UK"`
}

// Pagination carries pagination metadata for list responses.
type Pagination struct {
        Page       int   `json:"page"`
        PageSize   int   `json:"page_size"`
        Total      int64 `json:"total"`
        TotalPages int   `json:"total_pages"`
        HasNext    bool  `json:"has_next"`
}

// ListChatsResponse wraps a page of chats and pagination information.
type ListChatsResponse struct {
        Chats      []domain.Chat `json:"chats"`
        Pagination Pagination    `json:"pagination"`
}

//
// Helpers
//

// clampPagination parses and bounds page and page_size query params to sane
// defaults and limits, returning (page, pageSize).
func clampPagination(c *gin.Context) (page, pageSize int) <span class="cov5" title="6">{
        const (
                defaultPage     = 1
                defaultPageSize = 20
                maxPageSize     = 100
        )
        page = utils.AtoiDefault(c.Query("page"), defaultPage)
        if page &lt; 1 </span><span class="cov1" title="1">{
                page = 1
        }</span>
        <span class="cov5" title="6">pageSize = utils.AtoiDefault(c.Query("page_size"), defaultPageSize)
        if pageSize &lt; 1 </span><span class="cov1" title="1">{
                pageSize = 1
        }</span>
        <span class="cov5" title="6">if pageSize &gt; maxPageSize </span><span class="cov1" title="1">{
                pageSize = maxPageSize
        }</span>
        <span class="cov5" title="6">return</span>
}

//
// Handlers
//

// CreateChat godoc
// @ID          createChat
// @Summary     Create a new chat
// @Description Creates a chat for the current user and returns the chat resource.
// @Tags        Chats
// @Accept      json
// @Produce     json
//
// @Param       X-User-ID  header  string  false "User ID (demo header)"  example(user123)
// @Param       body       body    handlers.CreateChatRequest  true  "Create chat payload"
//
// @Success     201  {object}  domain.Chat
// @Failure     400  {object}  handlers.ErrorResponse  "Bad request"
// @Failure     500  {object}  handlers.ErrorResponse  "Internal error"
// @Router      /chats [post]
func (h *Handlers) CreateChat(c *gin.Context) <span class="cov3" title="3">{
        var req CreateChatRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "invalid JSON body")
                return
        }</span>
        <span class="cov2" title="2">title := strings.TrimSpace(req.Title)

        ch, err := h.chatSvc.Create(c.Request.Context(), userID(c), title)
        if err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusInternalServerError, ErrCodeCreateFailed, err.Error())
                return
        }</span>
        <span class="cov1" title="1">ok(c, http.StatusCreated, ch)</span>
}

// ListChats godoc
// @ID          listChats
// @Summary     List chats (paginated)
// @Description Returns a page of the user's chats. Supports weak ETag via If-None-Match and may return 304.
// @Tags        Chats
// @Produce     json
//
// @Param       X-User-ID      header  string  false "User ID (demo header)"       example(user123)
// @Param       If-None-Match  header  string  false "Return 304 if ETag matches"  example(W/\"abc123\")
// @Param       page           query   int     false "Page number"                  minimum(1) default(1)
// @Param       page_size      query   int     false "Items per page"               minimum(1) maximum(100) default(20)
//
// @Success     200  {object} handlers.ListChatsResponse
// @Header      200  {string} ETag           "Weak ETag for current result"
// @Header      200  {string} Cache-Control  "Caching directives (if set)"
// @Success     304  {string} string "Not Modified"
// @Failure     400  {object} handlers.ErrorResponse "Bad request"
// @Failure     500  {object} handlers.ErrorResponse "Internal error"
// @Router      /chats [get]
func (h *Handlers) ListChats(c *gin.Context) <span class="cov4" title="4">{
        ctx := c.Request.Context()
        uid := userID(c)
        page, pageSize := clampPagination(c)

        // ETag pre-check (best effort).
        var db *gorm.DB
        if svc, ok := h.chatSvc.(*services.ChatService); ok </span><span class="cov3" title="3">{
                db = svc.DB
        }</span>
        <span class="cov4" title="4">if db != nil </span><span class="cov3" title="3">{
                count, maxTS, err := repo.ChatsStats(ctx, db, uid)
                if err == nil </span><span class="cov3" title="3">{
                        var ts int64
                        if maxTS != nil </span><span class="cov2" title="2">{
                                ts = maxTS.Unix()
                        }</span>
                        <span class="cov3" title="3">etag := fmt.Sprintf(`W/"chats:%s:%d:%d"`, uid, count, ts)
                        c.Header("ETag", etag)
                        if inm := c.GetHeader("If-None-Match"); inm != "" &amp;&amp; inm == etag </span><span class="cov1" title="1">{
                                c.Status(http.StatusNotModified)
                                return
                        }</span>
                }
        }

        // Fetch page.
        <span class="cov3" title="3">items, total, err := h.chatSvc.ListPage(ctx, uid, page, pageSize)
        if err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusInternalServerError, ErrCodeListFailed, err.Error())
                return
        }</span>

        <span class="cov2" title="2">totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
        resp := ListChatsResponse{
                Chats: items,
                Pagination: Pagination{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                        HasNext:    page &lt; totalPages,
                },
        }
        ok(c, http.StatusOK, resp)</span>
}

// UpdateChatTitle godoc
// @ID          updateChatTitle
// @Summary     Rename a chat
// @Description Updates the title of a chat owned by the current user.
// @Tags        Chats
// @Accept      json
// @Produce     json
//
// @Param       X-User-ID  header  string  false "User ID (demo header)"         example(user123)
// @Param       id         path    string  true  "Chat ID (UUID)"                format(uuid) example(141add05-4415-4938-b5a1-17e0d3171aff)
// @Param       body       body    handlers.UpdateChatTitleRequest  true  "New title"
//
// @Success     204  {string} string "No Content"
// @Failure     400  {object} handlers.ErrorResponse "Bad request"
// @Failure     404  {object} handlers.ErrorResponse "Chat not found"
// @Failure     500  {object} handlers.ErrorResponse "Internal error"
// @Router      /chats/{id}/title [put]
func (h *Handlers) UpdateChatTitle(c *gin.Context) <span class="cov4" title="4">{
        chatID := c.Param("id")
        if _, err := uuid.Parse(chatID); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "chat id must be a UUID")
                return
        }</span>

        <span class="cov3" title="3">var req UpdateChatTitleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil || strings.TrimSpace(req.Title) == "" </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "title required (1–255 chars)")
                return
        }</span>

        <span class="cov2" title="2">if err := h.chatSvc.UpdateTitle(c.Request.Context(), userID(c), chatID, req.Title); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusNotFound, ErrCodeNotFound, "chat not found")
                return
        }</span>

        <span class="cov1" title="1">noContent(c)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Feedback HTTP handlers.
//
// This file exposes the REST endpoint for submitting feedback on assistant
// messages:
//   - POST /messages/{id}/feedback  (create feedback)
//
// Handlers in this file are transport-thin: they validate input, delegate to
// application services, and translate domain/service errors into HTTP results.
// Feedback values are constrained to {-1, +1} to represent negative/positive
// reactions respectively.
package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/tbourn/go-chat-backend/internal/services"
)

// LeaveFeedbackRequest is the JSON payload for creating feedback on a message.
//
// Value must be one of:
//   - +1 : positive feedback
//   - -1 : negative feedback
//
// The binding tag enforces the domain constraint at the transport layer.
type LeaveFeedbackRequest struct {
        // Value is the feedback signal: +1 (positive) or -1 (negative).
        Value   int     `json:"value" binding:"required,oneof=-1 1" example:"1"`
        Comment *string `json:"comment,omitempty" example:"Looks good"`
}

// LeaveFeedback godoc
// @ID          leaveFeedback
// @Summary     Leave feedback on a message
// @Description Records positive (+1) or negative (-1) feedback for an assistant message.
// @Tags        Feedback
// @Accept      json
// @Produce     json
//
// @Param       X-User-ID  header  string  false "User ID (demo header)"          example(user123)
// @Param       id         path    string  true  "Message ID (UUID)"              format(uuid) example(fa4dfbe0-c3bf-47bd-b32f-d7de221cf43b)
// @Param       body       body    handlers.LeaveFeedbackRequest true "Feedback payload"
//
// @Success     204  {string} string "No Content"
// @Failure     400  {object} handlers.ErrorResponse "Invalid payload"
// @Failure     403  {object} handlers.ErrorResponse "Not allowed to leave feedback"
// @Failure     404  {object} handlers.ErrorResponse "Message not found"
// @Failure     409  {object} handlers.ErrorResponse "Feedback already exists"
// @Failure     500  {object} handlers.ErrorResponse "Internal server error"
// @Router      /messages/{id}/feedback [post]
func (h *Handlers) LeaveFeedback(c *gin.Context) <span class="cov10" title="7">{
        var req LeaveFeedbackRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "value must be -1 or 1")
                return
        }</span>

        // Pull user from context → header → demo fallback (implemented in chat_handler.go)
        <span class="cov9" title="6">uid := userID(c)
        messageID := c.Param("id")

        if err := h.fbSvc.Leave(c.Request.Context(), uid, messageID, req.Value); err != nil </span><span class="cov8" title="5">{
                switch err </span>{
                case services.ErrMessageNotFound:<span class="cov1" title="1">
                        fail(c, http.StatusNotFound, ErrCodeNotFound, "message not found")</span>
                case services.ErrInvalidFeedback:<span class="cov1" title="1">
                        fail(c, http.StatusBadRequest, ErrCodeBadRequest, "value must be -1 or 1")</span>
                case services.ErrForbiddenFeedback:<span class="cov1" title="1">
                        fail(c, http.StatusForbidden, ErrCodeForbidden, "cannot leave feedback on this message")</span>
                case services.ErrDuplicateFeedback:<span class="cov1" title="1">
                        fail(c, http.StatusConflict, ErrCodeConflict, "feedback already exists")</span>
                default:<span class="cov1" title="1">
                        fail(c, http.StatusInternalServerError, ErrCodeInternal, err.Error())</span>
                }
                <span class="cov8" title="5">return</span>
        }

        <span class="cov1" title="1">noContent(c)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Message HTTP handlers.
//
// This file exposes REST endpoints for chat messages:
//   - POST /chats/{id}/messages   (append a user message and create assistant reply)
//   - GET  /chats/{id}/messages   (list paginated messages for a chat)
//
// Handlers are transport-thin:
//   - validate &amp; normalize inputs (including newline and length constraints)
//   - delegate to application services (MessageService)
//   - implement conditional responses (ETag) and idempotency semantics
//
// Idempotency:
// If the client supplies an Idempotency-Key header and a previous successful
// result exists for (user, chat, key), the handler returns that recorded
// assistant message and sets `Idempotency-Replayed: true`.
package handlers

import (
        "fmt"
        "net/http"
        "regexp"
        "strings"
        "time"
        "unicode/utf8"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
        "github.com/tbourn/go-chat-backend/internal/repo"
        "github.com/tbourn/go-chat-backend/internal/services"
        "github.com/tbourn/go-chat-backend/internal/utils"
)

//
// DTOs
//

// PostMessageRequest is the JSON payload for sending a user message.
//
// Content is normalized by the handler (line endings and excessive blank lines)
// before being passed to the service layer. The service also enforces a
// maximum rune count, which can be configured in MessageService.
type PostMessageRequest struct {
        // Content is the user prompt. It must be non-empty.
        Content string `json:"content" binding:"required,min=1" example:"What percentage of Gen Z in Nashville discover new brands through podcasts?"`
}

// PostMessageResponse is the JSON envelope for a newly created assistant message.
type PostMessageResponse struct {
        // Message is the assistant reply created as a result of the request.
        Message *domain.Message `json:"message"`
}

// ListMessagesResponse contains a page of chat messages and pagination metadata.
type ListMessagesResponse struct {
        Messages   []domain.Message `json:"messages"`
        Pagination Pagination       `json:"pagination"`
}

//
// Helpers
//

// clampMsgPagination parses page/page_size from query parameters, applies sane
// defaults and caps, and returns the validated (page, pageSize).
func clampMsgPagination(c *gin.Context) (page, pageSize int) <span class="cov7" title="5">{
        const (
                defaultPage     = 1
                defaultPageSize = 20
                maxPageSize     = 100
        )
        page = utils.AtoiDefault(c.Query("page"), defaultPage)
        if page &lt; 1 </span><span class="cov1" title="1">{
                page = 1
        }</span>
        <span class="cov7" title="5">pageSize = utils.AtoiDefault(c.Query("page_size"), defaultPageSize)
        if pageSize &lt; 1 </span><span class="cov1" title="1">{
                pageSize = 1
        }</span>
        <span class="cov7" title="5">if pageSize &gt; maxPageSize </span><span class="cov1" title="1">{
                pageSize = maxPageSize
        }</span>
        <span class="cov7" title="5">return</span>
}

// nlCollapseRE collapses runs of 3+ newlines to two, preserving paragraphs.
var nlCollapseRE = regexp.MustCompile(`\n{3,}`)

// sanitizeContent normalizes user text for consistent downstream behavior:
//   - converts CRLF/CR to LF,
//   - collapses runs of 3+ LFs to exactly two (paragraph separation),
//   - trims surrounding whitespace.
func sanitizeContent(raw string) string <span class="cov9" title="10">{
        s := strings.ReplaceAll(raw, "\r\n", "\n")
        s = strings.ReplaceAll(s, "\r", "\n")
        s = nlCollapseRE.ReplaceAllString(s, "\n\n")
        return strings.TrimSpace(s)
}</span>

// discoverMaxPromptRunes inspects the concrete MessageService for a configured
// prompt-length limit. If unavailable, it returns a conservative fallback.
func discoverMaxPromptRunes(msgSvc MessageService) int <span class="cov10" title="11">{
        const fallback = 4000
        if ms, ok := msgSvc.(*services.MessageService); ok </span><span class="cov7" title="5">{
                if ms.MaxPromptRunes &gt; 0 </span><span class="cov6" title="4">{
                        return ms.MaxPromptRunes
                }</span>
        }
        <span class="cov8" title="7">return fallback</span>
}

//
// Handlers
//

// PostMessage godoc
// @ID          postMessage
// @Summary     Send a message and get assistant reply
// @Description Appends a user message to the chat and generates an assistant reply.
// @Description Supports idempotency via the Idempotency-Key header (same key → same result).
// @Tags        Messages
// @Accept      json
// @Produce     json
//
// @Param       X-User-ID        header  string  true  "User ID that owns the chat"  example(user123)
// @Param       Idempotency-Key  header  string  false "Idempotency key for safe retries (UUID recommended)"  example(7a8d9f4c-1b2a-4c3d-8e9f-0123456789ab)
// @Param       id               path    string  true  "Chat ID (UUID)"              format(uuid)
// @Param       body             body    handlers.PostMessageRequest  true  "User message payload"
//
// @Success     200  {object}  handlers.PostMessageResponse  "Assistant reply"
// @Failure     400  {object}  handlers.ErrorResponse        "Bad request"
// @Failure     404  {object}  handlers.ErrorResponse        "Chat not found"
// @Failure     500  {object}  handlers.ErrorResponse        "Internal error"
// @Router      /chats/{id}/messages [post]
func (h *Handlers) PostMessage(c *gin.Context) <span class="cov9" title="10">{
        ctx := c.Request.Context()
        chatID := c.Param("id")

        // Validate chat id shape if you use UUIDs.
        if _, err := uuid.Parse(chatID); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "chat id must be a UUID")
                return
        }</span>

        <span class="cov9" title="9">var req PostMessageRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "content required")
                return
        }</span>

        // Sanitize + early size cap to fail fast at the edge.
        <span class="cov8" title="8">content := sanitizeContent(req.Content)
        maxRunes := discoverMaxPromptRunes(h.msgSvc)
        if maxRunes &gt; 0 &amp;&amp; utf8.RuneCountInString(content) &gt; maxRunes </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, fmt.Sprintf("content too long: max %d runes", maxRunes))
                return
        }</span>
        <span class="cov8" title="7">if content == "" </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "content required")
                return
        }</span>

        <span class="cov7" title="6">currentUser := userID(c)

        // Idempotency (replay path) – read validated key if present.
        idemKey, _ := middlewareGetIdempotencyKey(c)
        if idemKey != "" </span><span class="cov3" title="2">{
                if svc, okSvc := h.msgSvc.(*services.MessageService); okSvc &amp;&amp; svc.DB != nil </span><span class="cov3" title="2">{
                        if rec, err := repo.GetIdempotency(ctx, svc.DB, currentUser, chatID, idemKey, time.Now().UTC()); err == nil &amp;&amp; rec != nil </span><span class="cov1" title="1">{
                                if prev, err2 := repo.GetMessage(svc.DB, rec.MessageID); err2 == nil </span><span class="cov1" title="1">{
                                        c.Header("Idempotency-Replayed", "true")
                                        ok(c, http.StatusOK, PostMessageResponse{Message: prev})
                                        return
                                }</span>
                        }
                }
        }

        // Normal processing (service has a second guard for length).
        <span class="cov7" title="5">m, err := h.msgSvc.Answer(ctx, currentUser, chatID, content)
        if err != nil </span><span class="cov6" title="4">{
                switch err </span>{
                case services.ErrChatNotFound:<span class="cov1" title="1">
                        fail(c, http.StatusNotFound, ErrCodeNotFound, "chat not found")</span>
                case services.ErrTooLong:<span class="cov1" title="1">
                        fail(c, http.StatusBadRequest, ErrCodeBadRequest, fmt.Sprintf("content too long: max %d runes", maxRunes))</span>
                case services.ErrEmptyPrompt:<span class="cov1" title="1">
                        fail(c, http.StatusBadRequest, ErrCodeBadRequest, "content required")</span>
                default:<span class="cov1" title="1">
                        fail(c, http.StatusInternalServerError, ErrCodeAnswerFailed, err.Error())</span>
                }
                <span class="cov6" title="4">return</span>
        }

        // Idempotency (store path) – best effort.
        <span class="cov1" title="1">if idemKey != "" </span><span class="cov1" title="1">{
                if svc, ok := h.msgSvc.(*services.MessageService); ok &amp;&amp; svc.DB != nil </span><span class="cov1" title="1">{
                        ttl := 24 * time.Hour
                        _, _ = repo.CreateIdempotency(ctx, svc.DB, currentUser, chatID, idemKey, m.ID, http.StatusOK, ttl)
                }</span>
        }

        <span class="cov1" title="1">ok(c, http.StatusOK, PostMessageResponse{Message: m})</span>
}

// ListMessages godoc
// @ID          listMessages
// @Summary     List messages in a chat
// @Description Returns a paginated list of messages for the given chat.
// @Tags        Messages
// @Produce     json
//
// @Param       id         path   string  true  "Chat ID (UUID)"  format(uuid)
// @Param       page       query  int     false "Page number"     minimum(1) default(1)
// @Param       page_size  query  int     false "Items per page"  minimum(1) maximum(100) default(20)
//
// @Success     200  {object} handlers.ListMessagesResponse
// @Failure     400  {object} handlers.ErrorResponse "Bad request"
// @Failure     404  {object} handlers.ErrorResponse "Chat not found"
// @Failure     500  {object} handlers.ErrorResponse "Internal error"
// @Router      /chats/{id}/messages [get]
func (h *Handlers) ListMessages(c *gin.Context) <span class="cov7" title="5">{
        ctx := c.Request.Context()
        chatID := c.Param("id")

        if _, err := uuid.Parse(chatID); err != nil </span><span class="cov1" title="1">{
                fail(c, http.StatusBadRequest, ErrCodeBadRequest, "chat id must be a UUID")
                return
        }</span>

        // ETag pre-check (best effort).
        <span class="cov6" title="4">var db *gorm.DB
        if svc, ok := h.msgSvc.(*services.MessageService); ok </span><span class="cov1" title="1">{
                db = svc.DB
        }</span>
        <span class="cov6" title="4">if db != nil </span><span class="cov1" title="1">{
                count, maxTS, err := repo.MessagesStats(ctx, db, chatID)
                if err == nil </span><span class="cov1" title="1">{
                        var ts int64
                        if maxTS != nil </span><span class="cov1" title="1">{
                                ts = maxTS.Unix()
                        }</span>
                        <span class="cov1" title="1">etag := fmt.Sprintf(`W/"messages:%s:%d:%d"`, chatID, count, ts)
                        c.Header("ETag", etag)
                        if inm := c.GetHeader("If-None-Match"); inm != "" &amp;&amp; inm == etag </span><span class="cov1" title="1">{
                                c.Status(http.StatusNotModified)
                                return
                        }</span>
                }
        }

        <span class="cov5" title="3">page, pageSize := clampMsgPagination(c)

        items, total, err := h.msgSvc.ListPage(ctx, chatID, page, pageSize)
        if err != nil </span><span class="cov3" title="2">{
                switch err </span>{
                case services.ErrChatNotFound:<span class="cov1" title="1">
                        fail(c, http.StatusNotFound, ErrCodeNotFound, "chat not found")</span>
                default:<span class="cov1" title="1">
                        fail(c, http.StatusInternalServerError, ErrCodeListFailed, err.Error())</span>
                }
                <span class="cov3" title="2">return</span>
        }

        <span class="cov1" title="1">totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))
        ok(c, http.StatusOK, ListMessagesResponse{
                Messages: items,
                Pagination: Pagination{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                        HasNext:    page &lt; totalPages,
                },
        })</span>
}

// middlewareGetIdempotencyKey extracts an idempotency key if an upstream
// middleware has already validated/stashed it. The fallback behavior reads
// the "Idempotency-Key" header directly when no dedicated middleware exists.
func middlewareGetIdempotencyKey(c *gin.Context) (string, bool) <span class="cov8" title="8">{
        if v := strings.TrimSpace(c.GetHeader("Idempotency-Key")); v != "" </span><span class="cov5" title="3">{
                return v, true
        }</span>
        <span class="cov7" title="5">return "", false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package handlers provides HTTP handler implementations for the public API.
//
// This file defines the standard response utilities used across all endpoints,
// including structured error envelopes, consistent JSON serialization, and
// helpers for common HTTP patterns. The goal is to guarantee uniform responses
// for both success and failure cases, making the API predictable and
// machine-friendly.
//
// Conventions:
//   - All error responses must return an ErrorResponse with a stable `code`.
//   - `fail()` centralizes error logging and formatting, ensuring 5xx responses
//     are logged with request context for observability.
//   - `ok()` and `noContent()` simplify writing success responses in a consistent
//     shape across handlers.
//
// Example error response:
//
//        HTTP/1.1 404 Not Found
//        {
//          "request_id": "123e4567-e89b-12d3-a456-426614174000",
//          "code": "not_found",
//          "message": "resource not found"
//        }
//
// Example success response:
//
//        HTTP/1.1 200 OK
//        { "id": "abc123", "title": "New chat" }
package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/tbourn/go-chat-backend/internal/http/middleware"
)

// ErrorResponse is the standard error envelope returned by all endpoints.
//
// Fields:
//   - RequestID: Optional correlation ID, echoed from X-Request-ID header, used
//     to correlate server logs with client-side errors.
//   - Code: A stable, machine-readable string (see errors.go constants).
//   - Message: A human-readable error description, safe for display to users.
//
// This struct is used in OpenAPI documentation via Swagger annotations.
type ErrorResponse struct {
        // Correlates server logs and client errors
        RequestID string `json:"request_id,omitempty" example:"123e4567-e89b-12d3-a456-426614174000"`
        // Stable, machine-readable code (see errors.go constants)
        Code string `json:"code" example:"not_found"`
        // Human-readable message (safe to show to users)
        Message string `json:"message" example:"resource not found"`
}

// fail aborts the request with a structured error and logs server-side errors.
//
// It constructs an ErrorResponse, writes it as JSON with the given HTTP status,
// and calls gin.Context.AbortWithStatusJSON to stop further processing.
//
// Server errors (&gt;=500) are logged using the request-scoped logger from middleware.
func fail(c *gin.Context, status int, code, msg string) <span class="cov10" title="30">{
        reqID := c.Writer.Header().Get("X-Request-ID")
        resp := ErrorResponse{
                RequestID: reqID,
                Code:      code,
                Message:   msg,
        }

        // Log 5xx (server-side) with request-scoped logger
        if status &gt;= http.StatusInternalServerError </span><span class="cov5" title="6">{
                lg := middleware.LoggerFrom(c)
                lg.Error().
                        Int("status", status).
                        Str("code", code).
                        Str("message", msg).
                        Msg("api error")
        }</span>

        <span class="cov10" title="30">c.AbortWithStatusJSON(status, resp)</span>
}

// Fail is the exported variant of fail().
//
// External packages (e.g., router setup) should call Fail to return
// consistent error envelopes without directly depending on unexported helpers.
func Fail(c *gin.Context, status int, code, msg string) <span class="cov5" title="6">{ fail(c, status, code, msg) }</span>

// ok writes a success JSON response.
//
// It serializes `body` as JSON with the given HTTP status code.
func ok(c *gin.Context, status int, body any) <span class="cov6" title="7">{
        c.JSON(status, body)
}</span>

// noContent writes an HTTP 204 No Content response.
//
// Used when the operation succeeds but there is no response body.
func noContent(c *gin.Context) <span class="cov3" title="3">{
        c.Status(http.StatusNoContent)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package middleware contains shared Gin middleware used by the HTTP layer.
//
// This file implements idempotency support for unsafe HTTP methods (e.g., POST).
// It validates an Idempotency-Key request header, optionally performs a
// user-defined lookup to detect previously completed requests, and annotates
// the request context so downstream handlers can:
//   - read the normalized key (GetIdempotencyKey)
//   - detect replayed requests (IsReplay)
//   - bypass rate limiting when a replay is served (via an internal flag)
//
// Design goals:
//   - Keep transport concerns (validation, context stashing) in middleware.
//   - Decouple persistence via a narrow IdempotencyLookup function type.
//   - Remain framework-agnostic beyond Gin’s context.
package middleware

import (
        "context"
        "net/http"
        "regexp"
        "time"

        "github.com/gin-gonic/gin"
)

// HeaderIdempotencyKey is the canonical request header that clients use to
// convey an idempotency key for unsafe operations (e.g., POST).
//
// The value is expected to be stable for a given semantic operation so that
// retries (network, client, or server initiated) can be safely deduplicated.
const HeaderIdempotencyKey = "Idempotency-Key"

// Context keys used internally to stash idempotency state.
// These keys are intentionally unexported and referenced via accessor helpers.
const (
        ctxKeyIdemKey    = "idem.key"
        ctxKeyIdemReplay = "idem.replay" // bool: true when a stored replay exists
        ctxKeyRateBypass = "rate.bypass" // bool: true to skip rate limiting
)

// GetIdempotencyKey returns the validated idempotency key stored in the Gin
// context by IdempotencyValidator. The second return value indicates presence.
//
// Handlers should prefer this function over reading the header directly.
func GetIdempotencyKey(c *gin.Context) (string, bool) <span class="cov5" title="4">{
        v, ok := c.Get(ctxKeyIdemKey)
        if !ok </span><span class="cov3" title="2">{
                return "", false
        }</span>
        <span class="cov3" title="2">s, _ := v.(string)
        return s, s != ""</span>
}

// IsReplay reports whether the middleware detected that this request would
// replay a previously completed operation (based on the provided key/user/chat).
//
// When true, upstream components (e.g., handlers, rate limiters) may choose to
// short-circuit computation and return the previously persisted result.
func IsReplay(c *gin.Context) bool <span class="cov7" title="6">{
        v, ok := c.Get(ctxKeyIdemReplay)
        if !ok </span><span class="cov4" title="3">{
                return false
        }</span>
        <span class="cov4" title="3">b, _ := v.(bool)
        return b</span>
}

// IdempotencyOptions configures header validation behavior for
// IdempotencyValidator. TTL enforcement is intentionally out of scope here and
// should be implemented inside the provided lookup function.
type IdempotencyOptions struct {
        // MaxLen caps the accepted key length. Values &lt;= 0 default to 200.
        MaxLen int
        // Pattern restricts allowed characters. If nil, a conservative RFC7230-like
        // token pattern is used: ^[A-Za-z0-9._~\-:]+$
        Pattern *regexp.Regexp
        // NOTE: TTL is not enforced here; enforce it within your IdempotencyLookup.
}

// IdempotencyLookup answers whether a successful, still-valid result exists for
// (userID, chatID, key) at the given time. Implementations typically consult a
// database record containing the previous response metadata and TTL window.
//
// Return exists=true when the prior response can be replayed; return an error
// only for lookup failures (which should not block normal processing).
type IdempotencyLookup func(ctx context.Context, userID, chatID, key string, now time.Time) (exists bool, err error)

// IdempotencyValidator validates the Idempotency-Key header (if present), stashes
// it in the request context, and optionally checks for a prior completed request
// via the supplied lookup. When a replay is detected, it marks the context so
// downstream components can:
//   - detect replay via IsReplay
//   - bypass rate limiting (internal flag checked by your RL middleware)
//
// Behavior:
//   - If header is absent: the middleware is a no-op.
//   - If header fails validation: responds 400 with a compact error body.
//   - If lookup indicates a replay: sets replay + rate-bypass flags.
//   - Always invokes the next handler unless validation fails.
//
// This middleware does not itself return a cached payload; handlers remain in
// control of how to serve replays (e.g., by fetching previously persisted data).
func IdempotencyValidator(opts IdempotencyOptions, lookup IdempotencyLookup) gin.HandlerFunc <span class="cov9" title="11">{
        // Sensible defaults.
        maxLen := opts.MaxLen
        if maxLen &lt;= 0 </span><span class="cov6" title="5">{
                maxLen = 200
        }</span>
        <span class="cov9" title="11">pat := opts.Pattern
        if pat == nil </span><span class="cov8" title="10">{
                // RFC-7230-ish token + common safe chars.
                pat = regexp.MustCompile(`^[A-Za-z0-9._~\-:]+$`)
        }</span>

        <span class="cov9" title="11">return func(c *gin.Context) </span><span class="cov10" title="14">{
                key := c.GetHeader(HeaderIdempotencyKey)
                if key == "" </span><span class="cov7" title="6">{
                        // Nothing to validate or stash; proceed.
                        c.Next()
                        return
                }</span>
                <span class="cov8" title="8">if len(key) &gt; maxLen || !pat.MatchString(key) </span><span class="cov3" title="2">{
                        c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                                "code":    "bad_idempotency_key",
                                "message": "invalid Idempotency-Key",
                        })
                        return
                }</span>

                // Stash the normalized key for downstream use.
                <span class="cov7" title="6">c.Set(ctxKeyIdemKey, key)

                // If we can detect a previously stored response, mark replay + rate bypass.
                if lookup != nil </span><span class="cov6" title="5">{
                        uid := userIDFromCtx(c)
                        chatID := c.Param("id") // our POST /chats/:id/messages uses :id
                        now := time.Now().UTC()

                        if exists, _ := lookup(c.Request.Context(), uid, chatID, key, now); exists </span><span class="cov1" title="1">{
                                c.Set(ctxKeyIdemReplay, true)
                                c.Set(ctxKeyRateBypass, true) // let RL middleware skip limiting
                        }</span>
                }

                <span class="cov7" title="6">c.Next()</span>
        }
}

// userIDFromCtx extracts the user identifier from the Gin context as set by
// upstream authentication middleware. A development-friendly "demo-user"
// fallback is returned when no identity is available.
func userIDFromCtx(c *gin.Context) string <span class="cov8" title="8">{
        if v, ok := c.Get("userID"); ok </span><span class="cov4" title="3">{
                if s, ok := v.(string); ok &amp;&amp; s != "" </span><span class="cov3" title="2">{
                        return s
                }</span>
        }
        <span class="cov7" title="6">return "demo-user"</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package middleware contains shared Gin middleware used by the HTTP layer.
//
// This file provides structured request logging, a panic-safe recovery handler,
// and a request ID injector. The middleware in this module aims to deliver
// production-grade observability with minimal coupling:
//
//   - RequestID() ensures every request carries a stable correlation ID
//     (propagated via X-Request-ID and stored in the Gin context).
//   - Logger() emits structured access logs with request/response metadata
//     (latency, status, sizes), attaches a request-scoped zerolog.Logger, and
//     selects log level by outcome (info/warn/error).
//   - Recovery() converts panics into JSON 500 responses while preserving the
//     correlation ID and emitting a stack trace to logs.
//   - LoggerFrom() retrieves the request-scoped logger to enrich logs within
//     handlers and services (e.g., lg.Info().Str("chat_id", id).Msg("…")).
//
// Design notes:
//   - All middleware is safe to compose in any order, but for best results:
//     1) RequestID()
//     2) Logger() (or RedactingLogger if you use it)
//     3) Recovery()
//     so that panics and errors include the correlation ID and are logged.
//   - Query strings are truncated to a capped length to avoid log bloat.
//   - The request-scoped logger is stored under the "logger" Gin context key.
package middleware

import (
        "net/http"
        "runtime/debug"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

const (
        // requestIDKey is the Gin context key under which the request ID is stored.
        requestIDKey = "requestID"
        // requestIDHeader is the HTTP header used to propagate the correlation ID.
        requestIDHeader = "X-Request-ID"
        // maxQueryLogLength caps the number of bytes of the raw query string logged.
        maxQueryLogLength = 2048
)

// RequestID attaches (or propagates) a correlation identifier per request.
//
// Behavior:
//   - If the incoming request has X-Request-ID (header lookup is case-insensitive),
//     that value is reused. Otherwise, a new UUIDv4 is generated.
//   - The ID is written back to the response header (X-Request-ID) and stored
//     in the Gin context under the "requestID" key.
//
// Place this early in the chain so subsequent middleware/handlers can rely on
// the ID for logging and error responses.
func RequestID() gin.HandlerFunc <span class="cov8" title="12">{
        return func(c *gin.Context) </span><span class="cov10" title="19">{
                rid := c.GetHeader(requestIDHeader)
                if rid == "" </span><span class="cov9" title="17">{
                        rid = uuid.NewString()
                }</span>
                <span class="cov10" title="19">c.Set(requestIDKey, rid)
                c.Writer.Header().Set(requestIDHeader, rid)
                c.Next()</span>
        }
}

// Logger writes a structured access log for each request and response.
//
// Features:
//   - Records method, path (route when available), remote IP, UA, referer,
//     correlation ID, user ID (if present in context), request size,
//     response status, latency, and bytes written.
//   - Stores a request-scoped zerolog.Logger in the Gin context (key "logger")
//     so that downstream code can emit enriched logs tied to the request.
//   - Chooses log level based on outcome:
//   - error() for 5xx or when Gin context contains errors,
//   - warn()  for 4xx,
//   - info()  otherwise.
//
// Note: place this after RequestID() so logs include the correlation ID.
func Logger() gin.HandlerFunc <span class="cov5" title="4">{
        return func(c *gin.Context) </span><span class="cov6" title="6">{
                start := time.Now()

                // Build request-scoped logger with common fields.
                rid, _ := c.Get(requestIDKey)
                uid, _ := c.Get("userID")
                path := c.FullPath()
                if path == "" </span><span class="cov1" title="1">{
                        // Fallback when route not matched / 404.
                        path = c.Request.URL.Path
                }</span>

                <span class="cov6" title="6">l := log.With().
                        Str("request_id", asString(rid)).
                        Str("user_id", asString(uid)).
                        Str("method", c.Request.Method).
                        Str("path", path).
                        Str("remote_ip", c.ClientIP()).
                        Str("user_agent", c.Request.UserAgent()).
                        Str("referer", c.Request.Referer()).
                        Str("query", truncate(c.Request.URL.RawQuery, maxQueryLogLength)).
                        // ContentLength can be -1 if unknown.
                        Int64("bytes_in", c.Request.ContentLength).
                        Logger()

                // Make it available to handlers/services.
                c.Set("logger", &amp;l)

                c.Next()

                latency := time.Since(start)
                status := c.Writer.Status()
                bytesOut := c.Writer.Size()

                // Attach response fields &amp; emit at level based on status.
                ev := l.With().
                        Int("status", status).
                        Dur("latency", latency).
                        Int("bytes_out", bytesOut).
                        Logger()

                switch </span>{
                // If Gin collected errors, prefer error level.
                case len(c.Errors) &gt; 0:<span class="cov1" title="1">
                        ev.Error().Str("errors", c.Errors.String()).Msg("request")</span>
                case status &gt;= 500:<span class="cov1" title="1">
                        ev.Error().Msg("request")</span>
                case status &gt;= 400:<span class="cov1" title="1">
                        ev.Warn().Msg("request")</span>
                default:<span class="cov4" title="3">
                        ev.Info().Msg("request")</span>
                }
        }
}

// Recovery intercepts panics, logs a stack trace, and returns a JSON 500 error.
//
// Behavior:
//   - Logs the panic value and stack trace with the request ID.
//   - If no response has been written, emits a standardized JSON error body:
//     { "request_id": "...", "code": "internal_error", "message": "internal server error" }
//   - Ensures the X-Request-ID header is present on the response.
//
// Place this after Logger() so the panic is captured with structured context.
func Recovery() gin.HandlerFunc <span class="cov6" title="7">{
        return func(c *gin.Context) </span><span class="cov8" title="11">{
                defer func() </span><span class="cov8" title="11">{
                        if rec := recover(); rec != nil </span><span class="cov3" title="2">{
                                rid, _ := c.Get(requestIDKey)
                                log.Error().
                                        Interface("panic", rec).
                                        Bytes("stack", debug.Stack()).
                                        Str("request_id", asString(rid)).
                                        Msg("panic recovered")

                                // Only write if nothing has been written yet.
                                if !c.Writer.Written() </span><span class="cov1" title="1">{
                                        c.Header("Content-Type", "application/json")
                                        c.Header(requestIDHeader, asString(rid))
                                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                                                "request_id": asString(rid),
                                                "code":       "internal_error",
                                                "message":    "internal server error",
                                        })
                                        return
                                }</span>
                                <span class="cov1" title="1">c.AbortWithStatus(http.StatusInternalServerError)</span>
                        }
                }()
                <span class="cov8" title="11">c.Next()</span>
        }
}

// LoggerFrom returns the request-scoped zerolog.Logger.
//
// If a logger was not previously attached by Logger(), a fallback logger is
// returned (without request-scoped fields). Callers can safely use the result
// without nil checks.
func LoggerFrom(c *gin.Context) *zerolog.Logger <span class="cov7" title="8">{
        if v, ok := c.Get("logger"); ok </span><span class="cov3" title="2">{
                if lg, ok := v.(*zerolog.Logger); ok </span><span class="cov3" title="2">{
                        return lg
                }</span>
        }
        <span class="cov6" title="6">l := log.With().Logger()
        return &amp;l</span>
}

// asString converts an arbitrary interface to a string, returning an empty
// string when the value is not a string. Used for context values.
func asString(v interface{}) string <span class="cov9" title="18">{
        if s, ok := v.(string); ok </span><span class="cov8" title="11">{
                return s
        }</span>
        <span class="cov6" title="7">return ""</span>
}

// truncate returns s unchanged when within max length, otherwise it truncates
// s to max bytes and appends an ellipsis. A max &lt;= 0 disables truncation.
//
// Note: This operates on bytes (not runes) which is acceptable for logging.
func truncate(s string, max int) string <span class="cov7" title="9">{
        if max &lt;= 0 || len(s) &lt;= max </span><span class="cov7" title="8">{
                return s
        }</span>
        <span class="cov1" title="1">return s[:max] + "…"</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package middleware contains shared Gin middleware used by the HTTP layer.
//
// This file exposes Prometheus instrumentation for HTTP traffic. The Metrics()
// middleware measures request counts, latencies, in-flight concurrency, and
// response sizes with careful attention to label cardinality:
//
//   - method:   HTTP method verb (GET/POST/…)
//   - path:     the registered Gin route (e.g. /api/v1/chats/:id/messages);
//     falls back to the raw URL path when no route matched
//   - status:   numeric status code as a string (e.g. "200", "404")
//
// The chosen labels keep cardinality bounded while remaining actionable in
// dashboards and SLOs. All collectors are safe for concurrent use.
package middleware

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
)

var (
        // httpReqs counts requests by method, route path, and status code.
        httpReqs = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests.",
                },
                []string{"method", "path", "status"},
        )

        // httpLat records request duration in seconds by method and route path.
        // We intentionally omit status to keep latency histogram cardinality lower.
        httpLat = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests in seconds.",
                        Buckets: prometheus.DefBuckets, // suitable for general HTTP latency
                },
                []string{"method", "path"},
        )

        // httpInflight gauges the number of in-flight (currently processing) requests.
        httpInflight = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "http_requests_inflight",
                        Help: "Current number of in-flight HTTP requests.",
                },
        )

        // httpRespSize captures response sizes in bytes by method and route path.
        // Buckets are tuned for typical JSON API payload sizes.
        httpRespSize = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name: "http_response_size_bytes",
                        Help: "Size of HTTP responses in bytes.",
                        Buckets: []float64{
                                200, 500, 1 &lt;&lt; 10, 2 &lt;&lt; 10, 5 &lt;&lt; 10, // 200B..5KiB
                                10 &lt;&lt; 10, 25 &lt;&lt; 10, 50 &lt;&lt; 10, // 10..50KiB
                                100 &lt;&lt; 10, 250 &lt;&lt; 10, 500 &lt;&lt; 10, // 100..500KiB
                                1 &lt;&lt; 20, 2 &lt;&lt; 20, 5 &lt;&lt; 20, // 1..5MiB
                        },
                },
                []string{"method", "path"},
        )
)

func init() <span class="cov4" title="3">{
        prometheus.MustRegister(httpReqs, httpLat, httpInflight, httpRespSize)
}</span>

// Metrics returns a Gin middleware that instruments requests with Prometheus.
//
// Usage:
//
//        r := gin.New()
//        r.Use(middleware.Metrics())
//        r.GET("/metrics", gin.WrapH(promhttp.Handler()))
//
// Semantics:
//   - Increments http_requests_total(method, path, status) per request
//   - Observes http_request_duration_seconds(method, path) on completion
//   - Tracks http_requests_inflight gauge during handler execution
//   - Observes http_response_size_bytes(method, path) with bytes written
//
// Notes:
//   - The "path" label uses the registered route (c.FullPath()) to avoid
//     unbounded label cardinality from raw URLs. If no route matched (e.g. 404),
//     it falls back to c.Request.URL.Path.
//   - The status label is the numeric code string (e.g., "200"), which is easy
//     to aggregate in PromQL (e.g., sum by (status)).
func Metrics() gin.HandlerFunc <span class="cov7" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="12">{
                start := time.Now()
                httpInflight.Inc()
                defer httpInflight.Dec()

                c.Next()

                dur := time.Since(start).Seconds()
                path := c.FullPath()
                if path == "" </span><span class="cov7" title="6">{
                        path = c.Request.URL.Path
                }</span>
                <span class="cov10" title="12">method := c.Request.Method
                status := strconv.Itoa(c.Writer.Status())
                size := c.Writer.Size() // -1 when unknown

                httpReqs.WithLabelValues(method, path, status).Inc()
                httpLat.WithLabelValues(method, path).Observe(dur)
                if size &gt;= 0 </span><span class="cov9" title="10">{
                        httpRespSize.WithLabelValues(method, path).Observe(float64(size))
                }</span> else <span class="cov3" title="2">{
                        // Some handlers (e.g., hijacked connections) may not report size;
                        // we skip recording a negative value.
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package middleware contains shared Gin middleware used by the HTTP layer.
//
// This file implements a lightweight, in-memory, token-bucket rate limiter
// with per-identity buckets and opportunistic garbage collection. It is
// designed for simplicity, low overhead, and predictable behavior in a
// single-process deployment (e.g., a container or dev setup).
//
// Features:
//   - Per-key token buckets using golang.org/x/time/rate
//   - Pluggable identity function (user ID or client IP)
//   - Best-effort cleanup of idle buckets to bound memory
//   - Seamless bypass for idempotent replays (when paired with IdempotencyValidator)
//
// Notes:
//   - This limiter is process-local. For horizontally scaled deployments,
//     prefer a distributed limiter (e.g., Redis-backed) to enforce global limits.
//   - The limiter is intended for edge-level abuse control and cost protection;
//     it is not an authorization mechanism.
package middleware

import (
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/time/rate"
)

// keyFunc selects the identity used to key a rate-limit bucket.
//
// Implementations should return a stable string for the duration of a request
// (e.g., "user:&lt;id&gt;" or "ip:&lt;addr&gt;"). The returned key is used to look up the
// corresponding token bucket.
type keyFunc func(*gin.Context) string

// KeyByUserOrIP returns a keyFunc that prefers a user identity (from the Gin
// context under "userID", typically set by your auth middleware) and falls back
// to the client IP address.
//
// The resulting keys are prefixed to avoid collisions between user and IP
// namespaces (e.g., "user:abc123" vs "ip:203.0.113.7").
func KeyByUserOrIP() keyFunc <span class="cov8" title="10">{
        return func(c *gin.Context) string </span><span class="cov8" title="12">{
                if v, ok := c.Get("userID"); ok </span><span class="cov1" title="1">{
                        if s, ok := v.(string); ok &amp;&amp; s != "" </span><span class="cov1" title="1">{
                                return "user:" + s
                        }</span>
                }
                <span class="cov8" title="11">return "ip:" + c.ClientIP()</span>
        }
}

// visitor holds a single rate limiter and the last time it was seen.
// Used to opportunistically evict idle buckets.
type visitor struct {
        limiter  *rate.Limiter
        lastSeen time.Time
}

// RateLimiter implements a per-key token-bucket rate limiter.
//
// Buckets are created on demand and stored in an internal map guarded by a
// mutex. Idle buckets are evicted after a TTL via opportunistic cleanup during
// lookups to keep memory usage bounded.
//
// This type is safe for concurrent use.
type RateLimiter struct {
        rps      rate.Limit
        burst    int
        keyFn    keyFunc
        mu       sync.Mutex
        visitors map[string]*visitor

        ttl      time.Duration
        cleanupN uint64
}

// NewRateLimiter constructs a RateLimiter with the given tokens-per-second
// and burst size, keyed by keyFn.
//
//   - rps:   tokens replenished per second (0 allows no requests; use &gt;0).
//   - burst: maximum burst size; values &lt;= 0 are coerced to 1.
//   - keyFn: function that maps a request to a bucket identity.
//
// The returned limiter is ready to be installed as middleware via Handler().
func NewRateLimiter(rps float64, burst int, keyFn keyFunc) *RateLimiter <span class="cov7" title="8">{
        if burst &lt;= 0 </span><span class="cov1" title="1">{
                burst = 1
        }</span>
        <span class="cov7" title="8">return &amp;RateLimiter{
                rps:      rate.Limit(rps),
                burst:    burst,
                keyFn:    keyFn,
                visitors: make(map[string]*visitor),
                ttl:      10 * time.Minute, // evict idle entries after TTL
        }</span>
}

// getVisitor returns (and updates) the limiter for key, creating it if absent.
// It also performs opportunistic GC of idle entries after ~5000 lookups.
//
// IMPORTANT: Run GC *before* touching the requested visitor so an "old" bucket
// can be evicted even when it's the one being fetched.
func (rl *RateLimiter) getVisitor(key string) *rate.Limiter <span class="cov9" title="13">{
        now := time.Now()

        rl.mu.Lock()
        // Opportunistic cleanup after a threshold of lookups, then reset the counter.
        // Do this BEFORE updating/creating the requested visitor to avoid
        // refreshing an "old" entry that should be evicted.
        rl.cleanupN++
        if rl.cleanupN &gt;= 5000 </span><span class="cov1" title="1">{
                for k, vv := range rl.visitors </span><span class="cov1" title="1">{
                        // Evict if idle for &gt;= TTL (robust boundary check)
                        if now.Sub(vv.lastSeen) &gt;= rl.ttl </span><span class="cov1" title="1">{
                                delete(rl.visitors, k)
                        }</span>
                }
                <span class="cov1" title="1">rl.cleanupN = 0</span>
        }

        // Fetch or create this visitor.
        <span class="cov9" title="13">if v, ok := rl.visitors[key]; ok </span><span class="cov6" title="5">{
                v.lastSeen = now
                lim := v.limiter
                rl.mu.Unlock()
                return lim
        }</span>

        <span class="cov7" title="8">lim := rate.NewLimiter(rl.rps, rl.burst)
        rl.visitors[key] = &amp;visitor{limiter: lim, lastSeen: now}
        rl.mu.Unlock()
        return lim</span>
}

// IsRateBypass reports whether IdempotencyValidator marked this request for
// rate-limit bypass (i.e., it is a replay of a previously completed request).
//
// When true, Handler() will skip limiting so replays are served without
// consuming tokens.
func IsRateBypass(c *gin.Context) bool <span class="cov10" title="17">{
        v, ok := c.Get(ctxKeyRateBypass) // set by IdempotencyValidator
        if !ok </span><span class="cov9" title="13">{
                return false
        }</span>
        <span class="cov5" title="4">b, _ := v.(bool)
        return b</span>
}

// Handler returns a Gin middleware that enforces per-key token-bucket limits.
//
// Behavior:
//   - If IsRateBypass(c) is true (idempotent replay), limiting is skipped.
//   - Otherwise, the request is checked against the key’s limiter. If allowed,
//     the request proceeds; if not, a 429 response is returned with a compact
//     JSON body and a minimal Retry-After header.
//
// The middleware emits:
//
//        HTTP/1.1 429 Too Many Requests
//        {
//          "request_id": "&lt;uuid&gt;",
//          "code":       "rate_limited",
//          "message":    "rate limit exceeded"
//        }
func (rl *RateLimiter) Handler() gin.HandlerFunc <span class="cov7" title="7">{
        return func(c *gin.Context) </span><span class="cov8" title="11">{
                if IsRateBypass(c) </span><span class="cov1" title="1">{
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="10">key := rl.keyFn(c)
                lim := rl.getVisitor(key)

                if lim.Allow() </span><span class="cov7" title="9">{
                        c.Next()
                        return
                }</span>

                <span class="cov1" title="1">c.Header("Retry-After", "1")
                c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                        "request_id": c.Writer.Header().Get("X-Request-ID"),
                        "code":       "rate_limited",
                        "message":    "rate limit exceeded",
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package middleware contains shared Gin middleware used by the HTTP layer.
//
// This file implements RedactingLogger, a structured HTTP logger that
// automatically scrubs obvious PII from request metadata before emitting logs.
//
// Design goals:
//   - Default-safe: never logs request or response bodies
//   - Redacts common identifiers (emails, phone numbers, UUIDs)
//   - Masks sensitive headers (Authorization, Cookie, Set-Cookie, plus custom)
//   - Produces structured JSON logs via zerolog
//
// Usage:
//
//        r := gin.New()
//        r.Use(middleware.RedactingLogger(middleware.RedactOptions{
//            MaskHeaders: []string{"X-Api-Key"},
//        }))
//
// Security note: this middleware reduces but does not eliminate the risk of
// sensitive data leaking to logs. You should still ensure that clients and
// upstream services avoid transmitting PII in query strings or headers unless
// strictly necessary.
package middleware

import (
        "regexp"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog/log"
)

// RedactOptions configures additional scrub behavior for RedactingLogger.
//
// MaskHeaders specifies extra HTTP header names whose values will be fully
// replaced with "[REDACTED]". Matching is case-insensitive and merged with
// built-in sensitive headers ("Authorization", "Cookie", "Set-Cookie").
type RedactOptions struct {
        MaskHeaders []string
}

// RedactingLogger returns a Gin middleware that logs HTTP requests and
// responses with sensitive values scrubbed.
//
// Behavior:
//   - Logs method, path, query string, status, response size, latency,
//     and request headers (with scrubbing applied).
//   - Applies regex-based substitution to redact email addresses,
//     phone numbers, and UUID-like identifiers from query strings
//     and header values.
//   - Fully masks built-in sensitive headers and any additional headers
//     provided in opts.MaskHeaders.
//   - Logs in structured JSON format at INFO level by default, WARN for 4xx,
//     and ERROR for 5xx responses.
//
// NOTE: redact UUIDs *before* phone numbers to avoid the phone pattern
// accidentally matching the digit/hyphen segments of a UUID.
func RedactingLogger(opts RedactOptions) gin.HandlerFunc <span class="cov6" title="7">{
        // Compile regex patterns once.
        uuidRE := regexp.MustCompile(`(?i)\b[0-9a-f]{8}\-[0-9a-f]{4}\-[1-5][0-9a-f]{3}\-[89ab][0-9a-f]{3}\-[0-9a-f]{12}\b`)
        emailRE := regexp.MustCompile(`(?i)\b[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,}\b`)
        // Digits-only phone pattern (prevents matching hex characters from UUIDs).
        // Examples matched: "+1 212-555-1212", "212 555 1212", "(212) 555-1212".
        phoneRE := regexp.MustCompile(`\b(?:\+?\d{1,3}[ .-]?)?(?:\(?\d{2,4}\)?[ .-]?)?\d{3,4}[ .-]?\d{4}\b`)

        redact := func(s string) string </span><span class="cov10" title="23">{
                if s == "" </span><span class="cov7" title="11">{
                        return s
                }</span>
                <span class="cov8" title="12">out := s
                // Order matters: IDs → email → phone (phone is the loosest).
                out = uuidRE.ReplaceAllString(out, "[REDACTED:id]")
                out = emailRE.ReplaceAllString(out, "[REDACTED:email]")
                out = phoneRE.ReplaceAllString(out, "[REDACTED:phone]")
                return out</span>
        }

        // Build header mask set (case-insensitive).
        <span class="cov6" title="7">maskHeaders := map[string]struct{}{
                "authorization": {},
                "cookie":        {},
                "set-cookie":    {},
        }
        for _, h := range opts.MaskHeaders </span><span class="cov6" title="6">{
                if h = strings.ToLower(strings.TrimSpace(h)); h != "" </span><span class="cov6" title="6">{
                        maskHeaders[h] = struct{}{}
                }</span>
        }

        <span class="cov6" title="7">return func(c *gin.Context) </span><span class="cov8" title="12">{
                start := time.Now()

                // Request path and query.
                path := c.FullPath()
                if path == "" </span><span class="cov5" title="5">{
                        path = c.Request.URL.Path
                }</span>
                <span class="cov8" title="12">rawQuery := c.Request.URL.RawQuery
                safeQuery := redact(rawQuery)

                // Scrub headers.
                safeHeaders := make(map[string]string, len(c.Request.Header))
                for k, vv := range c.Request.Header </span><span class="cov8" title="14">{
                        keyLower := strings.ToLower(k)
                        val := strings.Join(vv, ", ")
                        if _, ok := maskHeaders[keyLower]; ok </span><span class="cov4" title="3">{
                                safeHeaders[k] = "[REDACTED]"
                                continue</span>
                        }
                        <span class="cov7" title="11">safeHeaders[k] = redact(val)</span>
                }

                <span class="cov8" title="12">c.Next()

                latency := time.Since(start)
                status := c.Writer.Status()
                size := c.Writer.Size()

                reqID := c.Writer.Header().Get("X-Request-ID")
                if reqID == "" </span><span class="cov2" title="2">{
                        reqID = c.GetHeader("X-Request-ID")
                }</span>

                // Severity based on status.
                <span class="cov8" title="12">ev := log.Info()
                switch </span>{
                case status &gt;= 500:<span class="cov1" title="1">
                        ev = log.Error()</span>
                case status &gt;= 400:<span class="cov6" title="6">
                        ev = log.Warn()</span>
                }

                <span class="cov8" title="12">ev.
                        Str("request_id", reqID).
                        Str("method", c.Request.Method).
                        Str("path", path).
                        Str("query", safeQuery).
                        Int("status", status).
                        Int("bytes", size).
                        Dur("latency", latency).
                        Interface("headers", safeHeaders).
                        Msg("http_request")</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package middleware contains shared Gin middleware used by the HTTP layer.
//
// This file provides SecurityHeaders, a hardening middleware that attaches a
// conservative set of HTTP security headers suitable for JSON APIs running
// behind a reverse proxy. It supports HSTS (when traffic is HTTPS end-to-end),
// cache controls for sensitive responses, and modern browser feature policies.
//
// Design notes:
//   - Safe defaults for APIs: no CSP here (only relevant when serving HTML)
//   - HSTS is opt-in and only applied when the request is actually HTTPS
//   - Header values are idempotent and inexpensive to compute per request
package middleware

import (
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
)

// SecurityOptions configures HTTP security headers emitted by SecurityHeaders.
//
// EnableHSTS controls whether to emit Strict-Transport-Security for HTTPS
// requests (never for plain HTTP). Only enable when traffic is HTTPS
// end-to-end (including between proxy and app).
//
// HSTSMaxAge is the lifetime for HSTS. Common values are 15552000 (180 days)
// or 31536000 (1 year). Defaults to 180 days if not set (&gt; 0 enforced).
//
// NoStore, when true, adds Cache-Control: no-store (plus legacy Pragma/Expires)
// to prevent caching of sensitive API responses.
//
// EnablePolicy controls whether modern browser feature policies are sent
// (Permissions-Policy and X-Permitted-Cross-Domain-Policies). They have effect
// only in user agents (browsers) and are harmless for non-browser clients.
type SecurityOptions struct {
        EnableHSTS   bool          // set true only when traffic is HTTPS end-to-end
        HSTSMaxAge   time.Duration // e.g., 180 * 24h
        NoStore      bool          // add Cache-Control: no-store
        EnablePolicy bool          // include Permissions-Policy, etc.
}

// SecurityHeaders returns a Gin middleware that adds a set of conservative,
// production-ready HTTP security headers to each response.
//
// Behavior:
//   - Always sets:
//     X-Content-Type-Options: nosniff
//     X-Frame-Options: DENY
//     Referrer-Policy: no-referrer
//   - Optionally sets (when EnablePolicy):
//     Permissions-Policy: geolocation=(), microphone=(), camera=(), payment=()
//     X-Permitted-Cross-Domain-Policies: none
//   - Optionally sets (when NoStore):
//     Cache-Control: no-store
//     Pragma: no-cache
//     Expires: 0
//   - Optionally sets (when EnableHSTS &amp;&amp; request is HTTPS):
//     Strict-Transport-Security: max-age=&lt;seconds&gt;; includeSubDomains; preload
//     Note: Do not enable HSTS for localhost or when traffic between proxy and
//     app is plain HTTP.
//   - If X-Request-ID is present, exposes it via Access-Control-Expose-Headers
//     so browser clients can read it.
//
// This middleware is safe to use alongside CORS and logging middlewares.
// For HTML routes, consider adding a Content-Security-Policy header at the
// template layer rather than here to avoid breaking non-HTML API clients.
func SecurityHeaders(opt SecurityOptions) gin.HandlerFunc <span class="cov7" title="10">{
        maxAge := int(opt.HSTSMaxAge.Seconds())
        if maxAge &lt;= 0 </span><span class="cov6" title="7">{
                maxAge = int((180 * 24 * time.Hour).Seconds()) // 180 days default
        }</span>
        <span class="cov7" title="10">return func(c *gin.Context) </span><span class="cov7" title="13">{
                h := c.Writer.Header()

                // Baseline hardening for APIs.
                h.Set("X-Content-Type-Options", "nosniff")
                h.Set("X-Frame-Options", "DENY")
                h.Set("Referrer-Policy", "no-referrer")

                // Optional modern browser feature restrictions (harmless for non-browsers).
                if opt.EnablePolicy </span><span class="cov6" title="9">{
                        h.Set("Permissions-Policy", "geolocation=(), microphone=(), camera=(), payment=()")
                        h.Set("X-Permitted-Cross-Domain-Policies", "none")
                }</span>

                // Prevent caching of sensitive API responses when requested.
                <span class="cov7" title="13">if opt.NoStore </span><span class="cov1" title="1">{
                        h.Set("Cache-Control", "no-store")
                        h.Set("Pragma", "no-cache")
                        h.Set("Expires", "0")
                }</span>

                // Strict-Transport-Security only for HTTPS requests (never for HTTP).
                <span class="cov7" title="13">if opt.EnableHSTS &amp;&amp; isHTTPS(c.Request) </span><span class="cov2" title="2">{
                        h.Set("Strict-Transport-Security",
                                "max-age="+itoa(maxAge)+"; includeSubDomains; preload")
                }</span>

                // Expose X-Request-ID for clients (useful for correlating logs).
                <span class="cov7" title="13">if rid := h.Get("X-Request-ID"); rid != "" </span><span class="cov7" title="11">{
                        // Append without clobbering existing exposed headers.
                        const hdr = "Access-Control-Expose-Headers"
                        cur := h.Get(hdr)
                        if cur == "" </span><span class="cov6" title="9">{
                                h.Set(hdr, "X-Request-ID")
                        }</span> else<span class="cov2" title="2"> if !strings.Contains(cur, "X-Request-ID") </span><span class="cov1" title="1">{
                                h.Set(hdr, cur+", X-Request-ID")
                        }</span>
                }

                <span class="cov7" title="13">c.Next()</span>
        }
}

// isHTTPS reports whether the incoming request used HTTPS either directly
// (r.TLS != nil) or via a reverse proxy that set X-Forwarded-Proto: https.
func isHTTPS(r *http.Request) bool <span class="cov5" title="6">{
        if r.TLS != nil </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov4" title="4">return strings.EqualFold(r.Header.Get("X-Forwarded-Proto"), "https")</span>
}

// itoa converts an int to its decimal string form without importing strconv.
// This keeps the middleware dependency surface minimal.
func itoa(i int) string <span class="cov7" title="10">{ return strconvItoa(i) }</span>

// strconvItoa is a small, allocation-free integer-to-string converter.
// It handles negatives and zero and returns a freshly sliced string.
func strconvItoa(i int) string <span class="cov7" title="10">{
        if i == 0 </span><span class="cov1" title="1">{
                return "0"
        }</span>
        <span class="cov6" title="9">neg := i &lt; 0
        if neg </span><span class="cov2" title="2">{
                i = -i
        }</span>
        <span class="cov6" title="9">var b [20]byte
        pos := len(b)
        for i &gt; 0 </span><span class="cov10" title="28">{
                pos--
                b[pos] = byte('0' + i%10)
                i /= 10
        }</span>
        <span class="cov6" title="9">if neg </span><span class="cov2" title="2">{
                pos--
                b[pos] = '-'
        }</span>
        <span class="cov6" title="9">return string(b[pos:])</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package httpapi wires the HTTP transport (Gin) to application services,
// middleware, and route handlers. It centralizes cross-cutting concerns such
// as tracing, correlation IDs, logging/redaction, panic recovery, metrics,
// CORS, security headers, idempotency, and rate limiting.
//
// Design goals:
//   - Put observability first (OTel + Prometheus)
//   - Safe-by-default middleware ordering (RequestID → logging → recovery)
//   - Deterministic, minimal router setup; all dependencies injected
//   - Production-ready CORS and security header posture
package httpapi

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/tbourn/go-chat-backend/internal/config"
        "github.com/tbourn/go-chat-backend/internal/domain"
        "github.com/tbourn/go-chat-backend/internal/http/handlers"
        "github.com/tbourn/go-chat-backend/internal/http/middleware"
        "github.com/tbourn/go-chat-backend/internal/repo"
        "github.com/tbourn/go-chat-backend/internal/search"
        "github.com/tbourn/go-chat-backend/internal/services"
        "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
        "golang.org/x/text/language"
        "gorm.io/gorm"
)

// chatRepoShim adapts the repository free functions to the services.ChatRepo
// interface expected by the ChatService. This keeps services decoupled from
// the concrete repo package while reusing existing functions.
type chatRepoShim struct{}

// CreateChat proxies repo.CreateChat.
func (chatRepoShim) CreateChat(ctx context.Context, db *gorm.DB, userID, title string) (*domain.Chat, error) <span class="cov5" title="3">{
        return repo.CreateChat(ctx, db, userID, title)
}</span>

// ListChats proxies repo.ListChats.
func (chatRepoShim) ListChats(ctx context.Context, db *gorm.DB, userID string) ([]domain.Chat, error) <span class="cov1" title="1">{
        return repo.ListChats(ctx, db, userID)
}</span>

// GetChat proxies repo.GetChat.
func (chatRepoShim) GetChat(ctx context.Context, db *gorm.DB, id, userID string) (*domain.Chat, error) <span class="cov3" title="2">{
        return repo.GetChat(ctx, db, id, userID)
}</span>

// UpdateChatTitle proxies repo.UpdateChatTitle.
func (chatRepoShim) UpdateChatTitle(ctx context.Context, db *gorm.DB, id, userID, title string) error <span class="cov1" title="1">{
        return repo.UpdateChatTitle(ctx, db, id, userID, title)
}</span>

// CountChats proxies repo.CountChats (pagination support).
func (chatRepoShim) CountChats(ctx context.Context, db *gorm.DB, userID string) (int64, error) <span class="cov1" title="1">{
        return repo.CountChats(ctx, db, userID)
}</span>

// ListChatsPage proxies repo.ListChatsPage (pagination support).
func (chatRepoShim) ListChatsPage(ctx context.Context, db *gorm.DB, userID string, offset, limit int) ([]domain.Chat, error) <span class="cov1" title="1">{
        return repo.ListChatsPage(ctx, db, userID, offset, limit)
}</span>

// RegisterRoutes attaches all middleware and HTTP endpoints to the given Gin
// engine. It configures observability (tracing, metrics), idempotency and rate
// limiting, CORS and security headers, health and metrics endpoints, and then
// mounts the versioned public API under /api/v*.
//
// Middleware order matters:
//  1. OpenTelemetry: trace everything
//  2. RequestID: generate/propagate correlation id
//  3. RedactingLogger: structured logs with PII scrubbing
//  4. Recovery: capture panics after logger
//  5. Body size limiter
//  6. Metrics
//  7. Idempotency validator (before rate limiter to allow bypass on replay)
//  8. Rate limiter (per user/IP, bypass on replay)
//  9. CORS and Security headers
func RegisterRoutes(r *gin.Engine, db *gorm.DB, idx search.Index, cfg config.Config) <span class="cov7" title="5">{
        r.HandleMethodNotAllowed = true

        // 1) Trace all HTTP requests
        r.Use(otelgin.Middleware(cfg.OTEL.ServiceName))

        // 2) Correlate requests and logs
        r.Use(middleware.RequestID())

        // 3) Structured logging with redaction
        r.Use(middleware.RedactingLogger(middleware.RedactOptions{
                MaskHeaders: []string{
                        "X-API-Key", // project-specific sensitive header example
                },
        }))

        // 4) Panic recovery to JSON 500 (with request id)
        r.Use(middleware.Recovery())

        // 5) Global body size limit (1 MiB)
        r.Use(limitBody(1 &lt;&lt; 20))

        // 6) Prometheus metrics and /metrics endpoint
        r.Use(middleware.Metrics())
        r.GET("/metrics", gin.WrapH(promhttp.Handler()))

        // 7) Idempotency validation (before rate limiting)
        r.Use(middleware.IdempotencyValidator(
                middleware.IdempotencyOptions{
                        MaxLen: 200,
                },
                func(ctx context.Context, userID, chatID, key string, now time.Time) (bool, error) </span><span class="cov5" title="3">{
                        rec, err := repo.GetIdempotency(ctx, db, userID, chatID, key, now)
                        if err != nil || rec == nil </span><span class="cov5" title="3">{
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return true, nil</span>
                },
        ))

        // 8) Token-bucket rate limiter per user/IP
        <span class="cov7" title="5">rl := middleware.NewRateLimiter(cfg.RateRPS, cfg.RateBurst, middleware.KeyByUserOrIP())
        r.Use(rl.Handler())

        // 9) CORS posture (safe defaults: allow all if none configured)
        if len(cfg.CORS.AllowedOrigins) == 0 </span><span class="cov6" title="4">{
                // Force ACAO: * even for requests without an Origin header (helps tests and simple health checks).
                r.Use(func(c *gin.Context) </span><span class="cov8" title="7">{
                        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                        c.Next()
                }</span>)
                <span class="cov6" title="4">r.Use(cors.New(cors.Config{
                        AllowAllOrigins:  true,
                        AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
                        AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization", "X-User-ID", middleware.HeaderIdempotencyKey},
                        ExposeHeaders:    []string{"X-Request-ID", "Content-Length"},
                        AllowCredentials: false, // must remain false with AllowAllOrigins
                        MaxAge:           12 * time.Hour,
                }))</span>
        } else<span class="cov1" title="1"> {
                // Echo ACAO with the request Origin when it is in the allowlist (in addition to gin-contrib/cors).
                allowed := make(map[string]struct{}, len(cfg.CORS.AllowedOrigins))
                for _, o := range cfg.CORS.AllowedOrigins </span><span class="cov1" title="1">{
                        allowed[o] = struct{}{}
                }</span>
                <span class="cov1" title="1">r.Use(func(c *gin.Context) </span><span class="cov1" title="1">{
                        if origin := c.GetHeader("Origin"); origin != "" </span><span class="cov1" title="1">{
                                if _, ok := allowed[origin]; ok </span><span class="cov1" title="1">{
                                        h := c.Writer.Header()
                                        h.Set("Access-Control-Allow-Origin", origin)
                                        h.Add("Vary", "Origin")
                                }</span>
                        }
                        <span class="cov1" title="1">c.Next()</span>
                })
                <span class="cov1" title="1">r.Use(cors.New(cors.Config{
                        AllowOrigins:     cfg.CORS.AllowedOrigins,
                        AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
                        AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization", "X-User-ID", middleware.HeaderIdempotencyKey},
                        ExposeHeaders:    []string{"X-Request-ID", "Content-Length"},
                        AllowCredentials: false,
                        MaxAge:           12 * time.Hour,
                }))</span>
        }

        // Security headers (HSTS only when enabled and request is HTTPS)
        <span class="cov7" title="5">r.Use(middleware.SecurityHeaders(middleware.SecurityOptions{
                EnableHSTS:   cfg.Security.EnableHSTS,
                HSTSMaxAge:   cfg.Security.HSTSMaxAge,
                NoStore:      false,
                EnablePolicy: true,
        }))

        // Fallbacks
        r.NoRoute(func(c *gin.Context) </span><span class="cov1" title="1">{
                handlers.Fail(c, http.StatusNotFound, handlers.ErrCodeNotFound, "route not found")
        }</span>)
        <span class="cov7" title="5">r.NoMethod(func(c *gin.Context) </span><span class="cov6" title="4">{
                handlers.Fail(c, http.StatusMethodNotAllowed, handlers.ErrCodeMethodNotAllowed, "method not allowed")
        }</span>)

        // Liveness/health
        <span class="cov7" title="5">r.GET("/health", func(c *gin.Context) </span><span class="cov5" title="3">{ c.JSON(http.StatusOK, gin.H{"status": "ok"}) }</span>)

        // Dependency injection: services ← repo/db/index
        <span class="cov7" title="5">chatSvc := services.NewChatService(db, chatRepoShim{})
        msgSvc := &amp;services.MessageService{
                DB:             db,
                Index:          idx,
                Threshold:      cfg.Threshold,
                MaxPromptRunes: 2000,
                MaxReplyRunes:  1500,
                TitleMaxLen:    6,
                TitleLocale:    language.English,
        }

        fbSvc := &amp;services.FeedbackService{DB: db}
        h := handlers.New(chatSvc, msgSvc, fbSvc)

        // Public API
        apiBase := cfg.APIBasePath // e.g. "/api/v1"
        api := groupWithPrefix(r, apiBase)
        </span><span class="cov7" title="5">{
                // Chats
                api.POST("/chats", h.CreateChat)
                api.GET("/chats", h.ListChats)
                api.PUT("/chats/:id/title", h.UpdateChatTitle)

                // Messages
                api.GET("/chats/:id/messages", h.ListMessages)
                api.POST("/chats/:id/messages", h.PostMessage)

                // Feedback
                api.POST("/messages/:id/feedback", h.LeaveFeedback)
        }</span>
}

// limitBody returns a Gin middleware that caps the request body size for all
// endpoints to maxBytes using http.MaxBytesReader. Requests exceeding the cap
// will cause downstream body reads to error.
func limitBody(maxBytes int64) gin.HandlerFunc <span class="cov8" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="10">{
                c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, maxBytes)
                c.Next()
        }</span>
}

// groupWithPrefix mounts a group at prefix, treating "/" (or empty) as root.
func groupWithPrefix(r *gin.Engine, prefix string) *gin.RouterGroup <span class="cov9" title="8">{
        if prefix == "" || prefix == "/" </span><span class="cov3" title="2">{
                return r.Group("")
        }</span>
        <span class="cov8" title="6">return r.Group(prefix)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package observability

import (
        "context"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.26.0"

        "google.golang.org/grpc/credentials"

        "github.com/tbourn/go-chat-backend/internal/config"
)

// ---- TEST SEAMS (signatures exactly match what tests will assign) ----
var (
        newOTLPClient = otlptracegrpc.NewClient

        // No exporter options exposed here -&gt; stable for tests.
        newOTLPExporterFn = func(ctx context.Context, client otlptrace.Client) (*otlptrace.Exporter, error) <span class="cov8" title="6">{
                return otlptrace.New(ctx, client)
        }</span>

        newServiceResourceFn = func(ctx context.Context, serviceName, version string) (*resource.Resource, error) <span class="cov7" title="5">{
                return resource.New(
                        ctx,
                        resource.WithAttributes(
                                semconv.ServiceName(serviceName),
                                semconv.ServiceVersion(version),
                        ),
                )
        }</span>
)

// ---------------------------------------------------------------------

// SetupOTel configures OpenTelemetry tracing and returns a shutdown function.
func SetupOTel(ctx context.Context, cfg config.OTELConfig, version string) (func(context.Context) error, error) <span class="cov10" title="8">{
        if !cfg.Enabled </span><span class="cov1" title="1">{
                return func(context.Context) error </span><span class="cov1" title="1">{ return nil }</span>, nil
        }

        // Build OTLP gRPC client options
        <span class="cov9" title="7">opts := []otlptracegrpc.Option{
                otlptracegrpc.WithEndpoint(cfg.Endpoint),
        }
        if cfg.Insecure </span><span class="cov8" title="6">{
                opts = append(opts, otlptracegrpc.WithInsecure())
        }</span> else<span class="cov1" title="1"> {
                creds := credentials.NewClientTLSFromCert(nil, "")
                opts = append(opts, otlptracegrpc.WithTLSCredentials(creds))
        }</span>

        // Exporter via seam
        <span class="cov9" title="7">client := newOTLPClient(opts...)
        exp, err := newOTLPExporterFn(ctx, client)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Resource via seam
        <span class="cov8" title="6">res, err := newServiceResourceFn(ctx, cfg.ServiceName, version)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Tracer provider
        <span class="cov7" title="5">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exp),
                sdktrace.WithSampler(sdktrace.ParentBased(sdktrace.TraceIDRatioBased(cfg.SampleRatio))),
                sdktrace.WithResource(res),
        )

        // Globals
        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{}, propagation.Baggage{},
        ))

        // Shutdown
        return tp.Shutdown, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package repo implements the data persistence layer for domain entities,
// backed by GORM. This file provides repository functions for the Chat model.
//
// All functions are context-aware and accept a *gorm.DB handle, making them
// safe for use within transactions or connection-scoped operations.
// They follow the "thin repository" approach: no business logic, only CRUD
// persistence and query composition.
//
// Error semantics:
//   - When a chat is not found, functions return gorm.ErrRecordNotFound
//     (also exported here as ErrNotFound for convenience).
//   - On DB errors (constraint violations, connectivity issues, etc.),
//     the raw gorm error is propagated.
//
// Functions:
//
//   - CreateChat(ctx, db, userID, title) -&gt; *domain.Chat, error
//     Inserts a new Chat row with UUID primary key and UTC timestamp.
//
//   - ListChats(ctx, db, userID) -&gt; []domain.Chat, error
//     Returns all chats for a user, ordered by creation time descending.
//
//   - CountChats(ctx, db, userID) -&gt; (int64, error)
//     Returns the total number of chats owned by the user.
//
//   - ListChatsPage(ctx, db, userID, offset, limit) -&gt; []domain.Chat, error
//     Returns a paginated slice of chats for a user.
//
//   - GetChat(ctx, db, id, userID) -&gt; *domain.Chat, error
//     Fetches a single chat by ID/userID, or ErrNotFound if missing.
//
//   - UpdateChatTitle(ctx, db, id, userID, title) -&gt; error
//     Updates the title of a chat, enforcing user ownership.
//     Returns ErrNotFound if the chat does not exist.
//
// Usage:
//
//        // Within a service layer
//        chat, err := repo.CreateChat(ctx, db, userID, "My first chat")
//        if errors.Is(err, repo.ErrNotFound) {
//            // handle missing
//        } else if err != nil {
//            // handle DB failure
//        }
//
// This repository is designed to be wrapped by a higher-level service
// (see services.ChatService) which enforces business rules, caching,
// or cross-aggregate behavior.
package repo

import (
        "context"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
)

// ErrNotFound is returned when a requested record does not exist.
// It aliases gorm.ErrRecordNotFound for convenience and consistency
// across the service layer and handlers.
var ErrNotFound = gorm.ErrRecordNotFound

// CreateChat inserts a new Chat row owned by userID with the given title.
// The chat ID is a randomly generated UUID (string), and CreatedAt is set to UTC.
//
// On success, it returns the persisted Chat. On failure, it returns a DB error.
func CreateChat(ctx context.Context, db *gorm.DB, userID, title string) (*domain.Chat, error) <span class="cov6" title="6">{
        c := &amp;domain.Chat{
                ID:        uuid.NewString(),
                UserID:    userID,
                Title:     title,
                CreatedAt: time.Now().UTC(),
        }
        if err := db.WithContext(ctx).Create(c).Error; err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="5">return c, nil</span>
}

// ListChats returns all chats belonging to userID, ordered by creation time
// descending (most recent first). It returns an empty slice if the user has
// no chats. On DB error, it returns the error.
func ListChats(ctx context.Context, db *gorm.DB, userID string) ([]domain.Chat, error) <span class="cov3" title="2">{
        var out []domain.Chat
        err := db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("created_at desc").
                Find(&amp;out).Error
        return out, err
}</span>

// CountChats returns the total number of chats owned by userID.
// On DB error, it returns the error.
func CountChats(ctx context.Context, db *gorm.DB, userID string) (int64, error) <span class="cov6" title="5">{
        var total int64
        err := db.WithContext(ctx).
                Model(&amp;domain.Chat{}).
                Where("user_id = ?", userID).
                Count(&amp;total).Error
        return total, err
}</span>

// ListChatsPage returns a paginated slice of chats for userID, ordered by
// creation time descending. Use CountChats to obtain the total for pagination
// metadata. On DB error, it returns the error.
//
// The caller is responsible for computing offset and limit (e.g., (page-1)*pageSize).
func ListChatsPage(ctx context.Context, db *gorm.DB, userID string, offset, limit int) ([]domain.Chat, error) <span class="cov4" title="3">{
        var out []domain.Chat
        err := db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("created_at desc").
                Offset(offset).
                Limit(limit).
                Find(&amp;out).Error
        return out, err
}</span>

// GetChat fetches a single chat by its ID and owner (userID). If the record
// does not exist, it returns ErrNotFound. On other DB errors, the raw error
// is returned.
func GetChat(ctx context.Context, db *gorm.DB, id, userID string) (*domain.Chat, error) <span class="cov10" title="16">{
        var c domain.Chat
        err := db.WithContext(ctx).
                Where("id = ? AND user_id = ?", id, userID).
                First(&amp;c).Error
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="13">return &amp;c, nil</span>
}

// UpdateChatTitle updates the title of a chat identified by id and owned by
// userID. If no rows are affected (chat missing or not owned by userID),
// it returns ErrNotFound. On DB error, the raw error is returned.
func UpdateChatTitle(ctx context.Context, db *gorm.DB, id, userID, title string) error <span class="cov6" title="5">{
        res := db.WithContext(ctx).
                Model(&amp;domain.Chat{}).
                Where("id = ? AND user_id = ?", id, userID).
                Update("title", title)
        if res.Error != nil </span><span class="cov1" title="1">{
                return res.Error
        }</span>
        <span class="cov5" title="4">if res.RowsAffected == 0 </span><span class="cov3" title="2">{
                return gorm.ErrRecordNotFound
        }</span>
        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package repo implements the data persistence layer for domain entities,
// backed by GORM. This file contains database bootstrapping helpers for
// SQLite (pure Go driver) and schema migrations.
package repo

import (
        "os"
        "path/filepath"
        "time"

        sqlite "github.com/glebarez/sqlite"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
)

// OpenSQLite opens (or creates) a SQLite database and applies PRAGMAs.
func OpenSQLite(path string) (*gorm.DB, error) <span class="cov10" title="2">{
        // Fail early if parent directory does not exist (instead of sqlite "out of memory (14)" on Windows).
        if dir := filepath.Dir(path); dir != "." </span><span class="cov10" title="2">{
                if _, err := os.Stat(dir); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov1" title="1">db, err := gorm.Open(sqlite.Open(path), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // PRAGMAs
        <span class="cov1" title="1">db.Exec("PRAGMA journal_mode=WAL;")
        db.Exec("PRAGMA synchronous=NORMAL;")
        db.Exec("PRAGMA foreign_keys=ON;")
        db.Exec("PRAGMA busy_timeout=5000;")

        // Pool
        if sqlDB, err := db.DB(); err == nil </span><span class="cov1" title="1">{
                sqlDB.SetMaxOpenConns(10)
                sqlDB.SetMaxIdleConns(10)
                sqlDB.SetConnMaxIdleTime(5 * time.Minute)
                sqlDB.SetConnMaxLifetime(30 * time.Minute)
        }</span>

        <span class="cov1" title="1">return db, nil</span>
}

// AutoMigrate keeps as you had it.
func AutoMigrate(db *gorm.DB) error <span class="cov1" title="1">{
        return db.AutoMigrate(
                &amp;domain.Chat{},
                &amp;domain.Message{},
                &amp;domain.Feedback{},
                &amp;domain.Idempotency{},
        )
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package repo implements the data persistence layer for domain entities,
// backed by GORM. This file provides repository functions for the Feedback model.
//
// The repository follows a "thin" approach: it performs persistence and simple
// query composition, leaving business rules to the services package.
//
// Error semantics:
//   - Duplicate feedback (same message_id,user_id) relies on the database
//     unique constraint and is returned as a raw DB error. The service layer
//     should translate that into a domain error (e.g., ErrDuplicateFeedback).
//   - On other DB errors (connectivity, constraints, etc.), the raw gorm
//     error is propagated.
//
// Functions:
//
//   - CreateFeedback(ctx, db, messageID, userID, value) -&gt; error
//     Inserts a feedback row. The (message_id,user_id) pair must be unique.
//
// Usage:
//
//        // In the service layer
//        err := repo.CreateFeedback(ctx, db, msgID, userID, +1)
//        if err != nil {
//            // detect unique-violation and translate to services.ErrDuplicateFeedback
//        }
package repo

import (
        "context"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
)

// CreateFeedback inserts a feedback row for the given message and user.
//
// The combination (message_id, user_id) must be unique, enforced by the
// database schema (unique index). If a duplicate exists, the database will
// return an error which should be translated by the service layer into a
// domain-level duplicate error.
//
// Value must be -1 (negative) or 1 (positive). Validation is expected to be
// enforced at higher layers (handlers/services) and/or via DB constraints.
//
// On success, it returns nil. On failure, it returns a DB error.
func CreateFeedback(ctx context.Context, db *gorm.DB, messageID, userID string, value int) error <span class="cov10" title="4">{
        fb := &amp;domain.Feedback{
                ID:        uuid.NewString(),
                MessageID: messageID,
                UserID:    userID,
                Value:     value,
                CreatedAt: time.Now().UTC(),
        }
        return db.WithContext(ctx).Create(fb).Error
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package repo implements the data persistence layer for domain entities,
// backed by GORM. This file provides repository helpers for the Idempotency
// model used to implement safe-retry semantics for POST endpoints.
package repo

import (
        "context"
        "errors"
        "strings"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
)

// ErrDuplicate indicates that an idempotency record already exists for the
// given (user_id, chat_id, key) tuple.
var ErrDuplicate = errors.New("duplicate")

// GetIdempotency returns a non-expired record or ErrNotFound.
func GetIdempotency(ctx context.Context, db *gorm.DB, userID, chatID, key string, now time.Time) (*domain.Idempotency, error) <span class="cov10" title="10">{
        if strings.TrimSpace(chatID) == "" </span><span class="cov6" title="4">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="6">var rec domain.Idempotency
        err := db.WithContext(ctx).
                Where("user_id = ? AND chat_id = ? AND key = ? AND expires_at &gt; ?", userID, chatID, key, now).
                First(&amp;rec).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov5" title="3">{
                return nil, ErrNotFound
        }</span>
        <span class="cov5" title="3">return &amp;rec, err</span>
}

// CreateIdempotency inserts a record and returns ErrDuplicate on unique violation.
func CreateIdempotency(ctx context.Context, db *gorm.DB, userID, chatID, key, messageID string, status int, ttl time.Duration) (*domain.Idempotency, error) <span class="cov7" title="5">{
        now := time.Now().UTC()
        rec := &amp;domain.Idempotency{
                ID:        uuid.NewString(),
                UserID:    userID,
                ChatID:    chatID,
                Key:       key,
                MessageID: messageID,
                Status:    status,
                CreatedAt: now,
                ExpiresAt: now.Add(ttl),
        }
        if err := db.WithContext(ctx).Create(rec).Error; err != nil </span><span class="cov3" title="2">{
                // glebarez/sqlite often returns plain-text errors for UNIQUE violations.
                low := strings.ToLower(err.Error())
                if errors.Is(err, gorm.ErrDuplicatedKey) ||
                        strings.Contains(low, "unique constraint failed") ||
                        strings.Contains(low, "constraint failed: unique") </span><span class="cov1" title="1">{
                        return nil, ErrDuplicate
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov5" title="3">return rec, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package repo implements the data persistence layer for domain entities,
// backed by GORM. This file provides repository functions for the Message model.
package repo

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
)

// CreateMessage inserts a new message row.
func CreateMessage(db *gorm.DB, chatID, role, content string, score *float64) (*domain.Message, error) <span class="cov9" title="10">{
        m := &amp;domain.Message{
                ID:        uuid.NewString(),
                ChatID:    chatID,
                Role:      role,
                Content:   content,
                Score:     score,
                CreatedAt: time.Now().UTC(),
        }
        return m, db.Create(m).Error
}</span>

// ListMessages returns messages ordered deterministically (CreatedAt ASC, ID ASC).
func ListMessages(db *gorm.DB, chatID string, limit int) ([]domain.Message, error) <span class="cov4" title="3">{
        var out []domain.Message
        q := db.Where("chat_id = ?", chatID).Order("created_at ASC, id ASC")
        if limit &gt; 0 </span><span class="cov3" title="2">{
                q = q.Limit(limit)
        }</span>
        <span class="cov4" title="3">err := q.Find(&amp;out).Error
        return out, err</span>
}

// CountMessages uses a raw COUNT so a missing table surfaces as an error (as tests expect).
func CountMessages(db *gorm.DB, chatID string) (int64, error) <span class="cov7" title="6">{
        var total int64
        err := db.Raw("SELECT COUNT(*) FROM messages WHERE chat_id = ?", chatID).Scan(&amp;total).Error
        return total, err
}</span>

// ListMessagesPage returns a paginated slice ordered (CreatedAt ASC, ID ASC).
func ListMessagesPage(db *gorm.DB, chatID string, offset, limit int) ([]domain.Message, error) <span class="cov4" title="3">{
        var out []domain.Message
        err := db.
                Where("chat_id = ?", chatID).
                Order("created_at ASC, id ASC").
                Offset(offset).
                Limit(limit).
                Find(&amp;out).Error
        return out, err
}</span>

// LeaveFeedback creates a feedback row for a message.
func LeaveFeedback(db *gorm.DB, messageID string, value int) error <span class="cov1" title="1">{
        fb := &amp;domain.Feedback{
                ID:        uuid.NewString(),
                MessageID: messageID,
                Value:     value,
                CreatedAt: time.Now().UTC(),
        }
        return db.Create(fb).Error
}</span>

// GetMessage fetches a message by ID.
func GetMessage(db *gorm.DB, id string) (*domain.Message, error) <span class="cov10" title="13">{
        var m domain.Message
        if err := db.Where("id = ?", id).First(&amp;m).Error; err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="10">return &amp;m, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package repo implements the data persistence layer for domain entities,
// backed by GORM. This file provides small aggregate/statistics queries used
// primarily for conditional responses (e.g., ETag generation) in the HTTP
// layer. Each function is context-aware and safe to call from services or
// handlers.
package repo

import (
        "context"
        "time"

        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
)

// ChatsStats returns aggregate metadata for a user's chats: the total number of
// rows and the maximum UpdatedAt timestamp among those rows.
//
// It executes two lightweight queries against the chats table scoped to the
// provided userID. When the user has no chats, the returned count is 0 and
// maxUpdatedAt is nil.
//
// Return values:
//   - count:        total chats for userID
//   - maxUpdatedAt: pointer to the greatest UpdatedAt, or nil if no rows
//   - err:          database error, if any
func ChatsStats(ctx context.Context, db *gorm.DB, userID string) (count int64, maxUpdatedAt *time.Time, err error) <span class="cov10" title="8">{
        q := db.WithContext(ctx).Model(&amp;domain.Chat{}).Where("user_id = ?", userID)

        // Count
        if err = q.Count(&amp;count).Error; err != nil </span><span class="cov1" title="1">{
                return 0, nil, err
        }</span>
        <span class="cov9" title="7">if count == 0 </span><span class="cov4" title="2">{
                return 0, nil, nil
        }</span>

        // Get latest updated_at (avoid MAX() -&gt; TEXT in SQLite)
        <span class="cov7" title="5">var row struct {
                UpdatedAt time.Time
        }
        if err = q.Select("updated_at").Order("updated_at DESC").Limit(1).Scan(&amp;row).Error; err != nil </span><span class="cov1" title="1">{
                return 0, nil, err
        }</span>
        <span class="cov7" title="4">return count, &amp;row.UpdatedAt, nil</span>
}

// MessagesStats returns aggregate metadata for messages within a given chat:
// the total number of rows and the maximum UpdatedAt timestamp among those rows.
//
// It executes two lightweight queries against the messages table scoped to the
// provided chatID. When the chat has no messages, the returned count is 0 and
// maxUpdatedAt is nil.
//
// Return values:
//   - count:        total messages for chatID
//   - maxUpdatedAt: pointer to the greatest UpdatedAt, or nil if no rows
//   - err:          database error, if any
func MessagesStats(ctx context.Context, db *gorm.DB, chatID string) (count int64, maxUpdatedAt *time.Time, err error) <span class="cov8" title="6">{
        q := db.WithContext(ctx).Model(&amp;domain.Message{}).Where("chat_id = ?", chatID)

        // Count
        if err = q.Count(&amp;count).Error; err != nil </span><span class="cov1" title="1">{
                return 0, nil, err
        }</span>
        <span class="cov7" title="5">if count == 0 </span><span class="cov1" title="1">{
                return 0, nil, nil
        }</span>

        // Get latest updated_at (avoid MAX() -&gt; TEXT in SQLite)
        <span class="cov7" title="4">var row struct {
                UpdatedAt time.Time
        }
        if err = q.Select("updated_at").Order("updated_at DESC").Limit(1).Scan(&amp;row).Error; err != nil </span><span class="cov1" title="1">{
                return 0, nil, err
        }</span>
        <span class="cov5" title="3">return count, &amp;row.UpdatedAt, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package search provides a simple, deterministic, concurrency-safe in-memory
// search index built from Markdown paragraphs. It is intentionally small and
// dependency-free, but engineered with production-grade ergonomics:
//
//   - No logging in the library (callers decide how/what to log)
//   - Clear, documented types and functional options (Option pattern)
//   - Unicode-aware tokenization with optional stop-word removal
//   - Immutable, read-only index after construction (safe for concurrent use)
//   - Deterministic scoring and sorting (stable order for ties)
//   - Sensible defaults (paragraph filtering, result caps)
//   - Backward-compatible Index interface (TopK(query, k int) []Result)
//
// Scoring uses Jaccard similarity between the query token set and each
// paragraph’s token set: score = |Q ∩ P| / |Q ∪ P|.
package search

import (
        "bytes"
        "io"
        "os"
        "regexp"
        "sort"
        "strings"
        "unicode/utf8"
)

// Result is a ranked snippet with its similarity score.
type Result struct {
        Snippet string
        Score   float64
}

// Index is the minimal interface implemented by all search indices.
type Index interface {
        TopK(query string, k int) []Result
}

// ----------------------------------------------------------------------------
// Options

type Option func(*config)

type config struct {
        minParagraphRunes int
        stopwords         map[string]struct{}
        maxDocs           int
}

func defaultConfig() config <span class="cov5" title="14">{
        return config{
                minParagraphRunes: 40,
                stopwords:         nil,
                maxDocs:           0,
        }
}</span>

func WithMinParagraphRunes(n int) Option <span class="cov4" title="12">{
        return func(c *config) </span><span class="cov4" title="12">{
                if n &gt;= 0 </span><span class="cov4" title="11">{
                        c.minParagraphRunes = n
                }</span>
        }
}

func WithStopwords(words []string) Option <span class="cov3" title="4">{
        return func(c *config) </span><span class="cov3" title="4">{
                m := make(map[string]struct{}, len(words))
                for _, w := range words </span><span class="cov4" title="8">{
                        w = strings.ToLower(strings.TrimSpace(w))
                        if w != "" </span><span class="cov4" title="7">{
                                m[w] = struct{}{}
                        }</span>
                }
                <span class="cov3" title="4">if len(m) &gt; 0 </span><span class="cov2" title="3">{
                        c.stopwords = m
                }</span>
        }
}

func WithMaxDocs(n int) Option <span class="cov2" title="3">{
        return func(c *config) </span><span class="cov2" title="3">{
                if n &gt; 0 </span><span class="cov2" title="2">{
                        c.maxDocs = n
                }</span>
        }
}

// ----------------------------------------------------------------------------
// Implementation

type doc struct {
        text   string
        tokens map[string]struct{}
        tLen   int
}

type index struct {
        cfg  config
        docs []doc
}

// NewIndexFromMarkdown builds an Index by reading the Markdown at path
// and delegating to NewIndexFromReader (in-memory).
func NewIndexFromMarkdown(path string, opts ...Option) (Index, error) <span class="cov2" title="2">{
        b, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;index{cfg: defaultConfig(), docs: nil}, err
        }</span>
        <span class="cov1" title="1">return NewIndexFromReader(bytes.NewReader(b), opts...)</span>
}

// NewIndexFromReader builds an Index from UTF-8 text provided by r.
// The reader is fully consumed; paragraphs are split on blank lines.
func NewIndexFromReader(r io.Reader, opts ...Option) (Index, error) <span class="cov2" title="3">{
        cfg := defaultConfig()
        for _, o := range opts </span><span class="cov2" title="2">{
                o(&amp;cfg)
        }</span>
        <span class="cov2" title="3">all, err := io.ReadAll(r)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;index{cfg: cfg, docs: nil}, err
        }</span>
        <span class="cov2" title="2">paras := splitParasFromBytes(all)
        return buildIndex(paras, cfg), nil</span>
}

// NewIndexFromStrings builds an Index directly from a slice of paragraphs.
func NewIndexFromStrings(paragraphs []string, opts ...Option) Index <span class="cov4" title="8">{
        cfg := defaultConfig()
        for _, o := range opts </span><span class="cov4" title="11">{
                o(&amp;cfg)
        }</span>
        <span class="cov4" title="8">return buildIndex(paragraphs, cfg)</span>
}

func buildIndex(paragraphs []string, cfg config) *index <span class="cov4" title="10">{
        docs := make([]doc, 0, len(paragraphs))
        count := 0
        for _, raw := range paragraphs </span><span class="cov6" title="25">{
                t := strings.TrimSpace(normalizeWhitespace(raw))
                if t == "" </span><span class="cov3" title="4">{
                        continue</span>
                }
                <span class="cov5" title="21">if cfg.minParagraphRunes &gt; 0 &amp;&amp; utf8.RuneCountInString(t) &lt; cfg.minParagraphRunes </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="20">toks := tokenize(t, cfg.stopwords)
                if len(toks) == 0 </span><span class="cov2" title="2">{
                        continue</span>
                }
                <span class="cov5" title="18">docs = append(docs, doc{text: t, tokens: toks, tLen: len(toks)})
                count++
                if cfg.maxDocs &gt; 0 &amp;&amp; count &gt;= cfg.maxDocs </span><span class="cov1" title="1">{
                        break</span>
                }
        }
        <span class="cov4" title="10">return &amp;index{cfg: cfg, docs: docs}</span>
}

// TopK returns up to k best-matching paragraphs by Jaccard similarity.
func (i *index) TopK(q string, k int) []Result <span class="cov4" title="9">{
        if len(i.docs) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov4" title="7">if strings.TrimSpace(q) == "" </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="6">if k &lt;= 0 </span><span class="cov1" title="1">{
                k = 3
        }</span>
        <span class="cov3" title="6">qTokens := tokenize(q, i.cfg.stopwords)
        if len(qTokens) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="6">qLen := len(qTokens)

        type scored struct {
                snippet  string
                score    float64
                lenRunes int
        }

        buf := make([]scored, 0, min(k*4, len(i.docs)))
        for _, d := range i.docs </span><span class="cov5" title="13">{
                over := overlap(qTokens, d.tokens)
                if over == 0 </span><span class="cov3" title="4">{
                        continue</span>
                }
                <span class="cov4" title="9">union := float64(qLen + d.tLen - over)
                if union &lt;= 0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="8">score := float64(over) / union
                if score &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">buf = append(buf, scored{
                        snippet:  d.text,
                        score:    score,
                        lenRunes: utf8.RuneCountInString(d.text),
                })</span>
        }
        <span class="cov3" title="6">if len(buf) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov3" title="4">sort.SliceStable(buf, func(a, b int) bool </span><span class="cov3" title="5">{
                if buf[a].score != buf[b].score </span><span class="cov2" title="2">{
                        return buf[a].score &gt; buf[b].score
                }</span>
                <span class="cov2" title="3">if buf[a].lenRunes != buf[b].lenRunes </span><span class="cov2" title="2">{
                        return buf[a].lenRunes &lt; buf[b].lenRunes
                }</span>
                <span class="cov1" title="1">return buf[a].snippet &lt; buf[b].snippet</span>
        })

        <span class="cov3" title="4">if k &gt; len(buf) </span><span class="cov2" title="3">{
                k = len(buf)
        }</span>
        <span class="cov3" title="4">out := make([]Result, k)
        for i := 0; i &lt; k; i++ </span><span class="cov4" title="8">{
                out[i] = Result{Snippet: buf[i].snippet, Score: buf[i].score}
        }</span>
        <span class="cov3" title="4">return out</span>
}

// ----------------------------------------------------------------------------
// Helpers

var wordRE = regexp.MustCompile(`\p{L}+\p{N}*`)

func tokenize(s string, stop map[string]struct{}) map[string]struct{} <span class="cov6" title="31">{
        s = strings.ToLower(s)
        words := wordRE.FindAllString(s, -1)
        if len(words) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov6" title="30">out := make(map[string]struct{}, len(words))
        for _, w := range words </span><span class="cov7" title="67">{
                if w == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="67">if stop != nil </span><span class="cov5" title="16">{
                        if _, skip := stop[w]; skip </span><span class="cov3" title="6">{
                                continue</span>
                        }
                }
                <span class="cov7" title="61">out[w] = struct{}{}</span>
        }
        <span class="cov6" title="30">return out</span>
}

func overlap(a, b map[string]struct{}) int <span class="cov5" title="18">{
        if len(a) == 0 || len(b) == 0 </span><span class="cov2" title="2">{
                return 0
        }</span>
        <span class="cov5" title="16">n := 0
        if len(a) &gt; len(b) </span><span class="cov1" title="1">{
                a, b = b, a
        }</span>
        <span class="cov5" title="16">for k := range a </span><span class="cov6" title="25">{
                if _, ok := b[k]; ok </span><span class="cov5" title="16">{
                        n++
                }</span>
        }
        <span class="cov5" title="16">return n</span>
}

func normalizeWhitespace(s string) string <span class="cov6" title="26">{
        var b strings.Builder
        b.Grow(len(s))
        prevSpace := false
        for _, r := range s </span><span class="cov10" title="299">{
                if r == ' ' || r == '\t' || r == '\r' </span><span class="cov7" title="46">{
                        if !prevSpace </span><span class="cov6" title="33">{
                                b.WriteByte(' ')
                                prevSpace = true
                        }</span>
                        <span class="cov7" title="46">continue</span>
                }
                <span class="cov9" title="253">prevSpace = false
                b.WriteRune(r)</span>
        }
        <span class="cov6" title="26">return b.String()</span>
}

var paraSplitRE = regexp.MustCompile(`\n\s*\n`)

func splitParasFromBytes(all []byte) []string <span class="cov2" title="3">{
        raw := string(all)
        chunks := paraSplitRE.Split(raw, -1)
        out := make([]string, 0, len(chunks))
        for _, c := range chunks </span><span class="cov4" title="7">{
                if t := strings.TrimSpace(c); t != "" </span><span class="cov4" title="7">{
                        out = append(out, t)
                }</span>
        }
        <span class="cov2" title="3">return out</span>
}

func min(a, b int) int <span class="cov4" title="8">{
        if a &lt; b </span><span class="cov1" title="1">{
                return a
        }</span>
        <span class="cov4" title="7">return b</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package search

import (
        "bufio"
        "os"
        "strings"
)

// PrepareMarkdownInMemory reads the markdown at `path`, flattens any table rows
// into standalone facts, and returns the processed bytes. If no transform was
// needed, it returns the original file bytes.
//
// Notes:
//   - Avoids emitting a leading blank line.
//   - Normalizes the tail to end with exactly one newline.
func PrepareMarkdownInMemory(path string) ([]byte, error) <span class="cov6" title="5">{
        orig, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="4">f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="4">defer f.Close()

        var b strings.Builder
        sc := bufio.NewScanner(f)
        sc.Buffer(make([]byte, 0, 64*1024), 4*1024*1024)

        wroteAny := false
        wroteBlank := true // start true to avoid a leading blank
        sawTable := false

        writeFact := func(s string) </span><span class="cov8" title="9">{
                s = strings.TrimSpace(s)
                if s == "" || strings.EqualFold(s, "text") </span><span class="cov3" title="2">{
                        return
                }</span>
                <span class="cov7" title="7">b.WriteString(s)
                b.WriteByte('\n')
                b.WriteByte('\n')
                wroteAny = true
                wroteBlank = true</span>
        }

        <span class="cov5" title="4">for sc.Scan() </span><span class="cov10" title="15">{
                line := strings.TrimSpace(sc.Text())
                if line == "" </span><span class="cov6" title="5">{
                        if !wroteBlank </span><span class="cov1" title="1">{
                                b.WriteByte('\n')
                                wroteBlank = true
                        }</span>
                        <span class="cov6" title="5">continue</span>
                }

                // table row: "| ... |"
                <span class="cov8" title="10">if strings.HasPrefix(line, "|") &amp;&amp; strings.HasSuffix(line, "|") </span><span class="cov6" title="6">{
                        sawTable = true
                        raw := strings.Trim(line, "|")
                        cols := strings.Split(raw, "|")

                        allSep := true
                        cleaned := make([]string, 0, len(cols))
                        for _, c := range cols </span><span class="cov8" title="11">{
                                cell := strings.TrimSpace(c)
                                if cell != "" </span><span class="cov8" title="10">{
                                        cleaned = append(cleaned, cell)
                                }</span>
                                <span class="cov8" title="11">tmp := strings.ReplaceAll(cell, ":", "")
                                tmp = strings.ReplaceAll(tmp, "-", "")
                                if strings.TrimSpace(tmp) != "" </span><span class="cov7" title="8">{
                                        allSep = false
                                }</span>
                        }
                        <span class="cov6" title="6">if allSep || len(cleaned) == 0 </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov6" title="5">if len(cleaned) == 1 </span><span class="cov3" title="2">{
                                writeFact(cleaned[0])
                                continue</span>
                        }
                        <span class="cov4" title="3">writeFact(strings.Join(cleaned, " "))
                        continue</span>
                }

                // non-table line → one fact per line
                <span class="cov5" title="4">wroteBlank = false
                writeFact(line)</span>
        }
        <span class="cov5" title="4">if err := sc.Err(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // No transform → original bytes
        <span class="cov4" title="3">if !sawTable &amp;&amp; !wroteAny </span><span class="cov1" title="1">{
                return orig, nil
        }</span>

        <span class="cov3" title="2">out := b.String()
        if sawTable </span><span class="cov1" title="1">{
                // Table flows expect a single trailing newline
                out = strings.TrimRight(out, "\n") + "\n"
        }</span>
        // For non-table flows, keep the natural "\n\n" tail
        <span class="cov3" title="2">return []byte(out), nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package services – ChatService
//
// This file implements the ChatService, which manages the lifecycle of chats.
// It validates and normalizes titles, enforces ownership rules, and coordinates
// repository operations for creating, listing (with pagination), and updating
// chats. Title handling is intentionally minimal here because automatic title
// generation is performed in MessageService on the first user message.
//
// Service-level errors (e.g., ErrChatNotFound) are returned for predictable
// cases so handlers can map them to HTTP results consistently.
package services

import (
        "context"
        "errors"
        "regexp"
        "strings"
        "unicode/utf8"

        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
        "golang.org/x/text/language"
)

// ChatRepo defines the repository contract required by ChatService.
// Implementations are responsible for persistence of chat aggregates.
type ChatRepo interface {
        // CreateChat inserts a new chat row for the given user.
        CreateChat(ctx context.Context, db *gorm.DB, userID, title string) (*domain.Chat, error)

        // ListChats returns all chats belonging to the user (non-paginated).
        ListChats(ctx context.Context, db *gorm.DB, userID string) ([]domain.Chat, error)

        // GetChat fetches a chat by ID ensuring it belongs to the user.
        GetChat(ctx context.Context, db *gorm.DB, id, userID string) (*domain.Chat, error)

        // UpdateChatTitle updates a chat’s title (only if it belongs to the user).
        UpdateChatTitle(ctx context.Context, db *gorm.DB, id, userID, title string) error

        // CountChats returns the total number of chats for pagination.
        CountChats(ctx context.Context, db *gorm.DB, userID string) (int64, error)

        // ListChatsPage returns a page of chats belonging to the user.
        ListChatsPage(ctx context.Context, db *gorm.DB, userID string, offset, limit int) ([]domain.Chat, error)
}

// ChatService provides chat-level operations such as creating,
// listing, and updating chat metadata. It enforces title rules
// and ensures ownership constraints.
type ChatService struct {
        // DB is the GORM handle used for persistence.
        DB *gorm.DB
        // Repo is the chat repository used by this service.
        Repo ChatRepo

        // TitleMaxLen caps stored titles by rune length.
        TitleMaxLen int
        // TitleLocale is retained for compatibility; auto-titling is handled in MessageService.
        TitleLocale language.Tag
}

// NewChatService constructs a ChatService with sane defaults for title handling.
func NewChatService(db *gorm.DB, r ChatRepo) *ChatService <span class="cov10" title="21">{
        return &amp;ChatService{
                DB:          db,
                Repo:        r,
                TitleMaxLen: 60,
                TitleLocale: language.Und,
        }
}</span>

// Create inserts a new chat owned by userID with the provided title.
// Titles are normalized, trimmed, clipped, and a default fallback is applied.
func (s *ChatService) Create(ctx context.Context, userID, title string) (*domain.Chat, error) <span class="cov4" title="3">{
        title = normalizeTitle(title)
        if title == "" </span><span class="cov1" title="1">{
                title = "New chat"
        }</span>
        <span class="cov4" title="3">return s.Repo.CreateChat(ctx, s.DB, userID, s.clip(title))</span>
}

// List returns all chats for a user (non-paginated).
// Prefer ListPage for scalability on large datasets.
func (s *ChatService) List(ctx context.Context, userID string) ([]domain.Chat, error) <span class="cov1" title="1">{
        return s.Repo.ListChats(ctx, s.DB, userID)
}</span>

// ListPage returns a page of chats for a user (paginated).
// It applies defaults for invalid page/pageSize and returns total count.
func (s *ChatService) ListPage(ctx context.Context, userID string, page, pageSize int) ([]domain.Chat, int64, error) <span class="cov6" title="6">{
        if page &lt; 1 </span><span class="cov3" title="2">{
                page = 1
        }</span>
        <span class="cov6" title="6">if pageSize &lt;= 0 </span><span class="cov3" title="2">{
                pageSize = 20
        }</span>
        <span class="cov6" title="6">offset := (page - 1) * pageSize

        total, err := s.Repo.CountChats(ctx, s.DB, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>
        <span class="cov5" title="5">if total == 0 </span><span class="cov3" title="2">{
                return []domain.Chat{}, 0, nil
        }</span>

        <span class="cov4" title="3">items, err := s.Repo.ListChatsPage(ctx, s.DB, userID, offset, pageSize)
        return items, total, err</span>
}

// UpdateTitle updates a chat’s title, ensuring the chat exists and
// belongs to the given user. Falls back to "Untitled" if title is blank.
func (s *ChatService) UpdateTitle(ctx context.Context, userID, chatID, title string) error <span class="cov5" title="4">{
        title = normalizeTitle(title)
        if title == "" </span><span class="cov1" title="1">{
                title = "Untitled"
        }</span>
        // Ensure the chat exists and belongs to the user.
        <span class="cov5" title="4">if _, err := s.Repo.GetChat(ctx, s.DB, chatID, userID); err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return ErrChatNotFound
                }</span>
                <span class="cov1" title="1">return err</span>
        }
        <span class="cov3" title="2">return s.Repo.UpdateChatTitle(ctx, s.DB, chatID, userID, s.clip(title))</span>
}

// clip truncates a chat title to the configured maximum rune length.
func (s *ChatService) clip(title string) string <span class="cov6" title="7">{
        if s.TitleMaxLen &gt; 0 &amp;&amp; utf8.RuneCountInString(title) &gt; s.TitleMaxLen </span><span class="cov4" title="3">{
                return string([]rune(title)[:s.TitleMaxLen])
        }</span>
        <span class="cov5" title="4">return title</span>
}

// normalizeTitle trims whitespace and collapses multiple spaces to one.
func normalizeTitle(s string) string <span class="cov8" title="14">{
        s = whitespaceRE.ReplaceAllString(strings.TrimSpace(s), " ")
        return s
}</span>

// whitespaceRE collapses consecutive whitespace to a single space.
var whitespaceRE = regexp.MustCompile(`\s+`)
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package services – FeedbackService
//
// This file implements the FeedbackService, which governs how users leave
// feedback (-1 or +1) on assistant messages. It enforces business rules
// (message existence, chat ownership, assistant-only restriction, uniqueness)
// and persists feedback atomically in the database. Service-level errors
// (e.g. ErrInvalidFeedback, ErrMessageNotFound, ErrForbiddenFeedback,
// ErrDuplicateFeedback) are returned for predictable cases so handlers can
// map them to HTTP results consistently.
package services

import (
        "context"
        "errors"
        "strings"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
        "github.com/tbourn/go-chat-backend/internal/repo"
)

// FeedbackService implements the use-cases around message feedback.
// It validates the operation (ownership, message role, uniqueness) and persists
// the feedback using the provided GORM handle. The service is context-aware and
// safe to use inside transactions (it will open its own transaction per call).
type FeedbackService struct {
        // DB is the database handle used for all feedback operations.
        // The handle may be a plain *gorm.DB or a transaction-bound handle.
        DB *gorm.DB
}

// Leave records a feedback value for messageID on behalf of userID.
//
// Semantics and validation:
//   - value must be exactly -1 (negative) or 1 (positive); otherwise ErrInvalidFeedback.
//   - messageID must exist; otherwise ErrMessageNotFound.
//   - The message must belong to a chat owned by userID; otherwise ErrForbiddenFeedback.
//   - Feedback is allowed only for assistant messages; user messages are rejected
//     with ErrForbiddenFeedback.
//   - A user may leave at most one feedback per message; attempting to do so
//     again yields ErrDuplicateFeedback.
//
// Concurrency &amp; atomicity:
//   - The operation runs inside a transaction to ensure the existence/ownership
//     checks and the insert are atomic.
//
// Errors:
//   - Returns the service-level sentinel errors (ErrInvalidFeedback,
//     ErrMessageNotFound, ErrForbiddenFeedback, ErrDuplicateFeedback) for the
//     validation cases above.
//   - Returns the underlying DB error for unexpected failures.
func (s *FeedbackService) Leave(ctx context.Context, userID, messageID string, value int) error <span class="cov10" title="10">{
        if value != -1 &amp;&amp; value != 1 </span><span class="cov1" title="1">{
                return ErrInvalidFeedback
        }</span>

        <span class="cov9" title="9">return s.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov9" title="9">{
                // 1) Load message and verify it exists.
                msg, err := repo.GetMessage(tx, messageID)
                if err != nil </span><span class="cov3" title="2">{
                        // repo.GetMessage returns gorm.ErrRecordNotFound if missing.
                        if errors.Is(err, gorm.ErrRecordNotFound) || isNotFound(err) </span><span class="cov1" title="1">{
                                return ErrMessageNotFound
                        }</span>
                        <span class="cov1" title="1">return err</span>
                }

                // 2) Ensure the message's chat belongs to this user.
                <span class="cov8" title="7">if _, err := repo.GetChat(ctx, tx, msg.ChatID, userID); err != nil </span><span class="cov1" title="1">{
                        // either not found or not owned by this user
                        return ErrForbiddenFeedback
                }</span>

                // 3) Only allow feedback on assistant messages.
                <span class="cov8" title="6">if msg.Role != "assistant" </span><span class="cov1" title="1">{
                        return ErrForbiddenFeedback
                }</span>

                // 4) Insert feedback with (message_id, user_id) uniqueness semantics.
                <span class="cov7" title="5">fb := &amp;domain.Feedback{
                        ID:        uuid.NewString(),
                        MessageID: messageID,
                        UserID:    userID,
                        Value:     value,
                        CreatedAt: time.Now().UTC(),
                }
                if err := tx.Create(fb).Error; err != nil </span><span class="cov5" title="3">{
                        // Map duplicate key to a stable service error.
                        if errors.Is(err, gorm.ErrDuplicatedKey) || isDuplicate(err) </span><span class="cov3" title="2">{
                                return ErrDuplicateFeedback
                        }</span>
                        <span class="cov1" title="1">return err</span>
                }
                <span class="cov3" title="2">return nil</span>
        })
}

// isNotFound treats repo-level not found sentinels as "not found" in a
// driver-agnostic way. It also checks gorm.ErrRecordNotFound for safety.
func isNotFound(err error) bool <span class="cov5" title="3">{
        // If your repo exposes ErrNotFound, detect it here:
        if errors.Is(err, repo.ErrNotFound) </span><span class="cov1" title="1">{
                return true
        }</span>
        // Fallback to GORM's sentinel.
        <span class="cov3" title="2">return errors.Is(err, gorm.ErrRecordNotFound)</span>
}

// isDuplicate attempts to detect unique-constraint violations across drivers
// that may not map to gorm.ErrDuplicatedKey.
func isDuplicate(err error) bool <span class="cov7" title="5">{
        // SQLite typically: "UNIQUE constraint failed"
        // Postgres typically: "duplicate key value violates unique constraint"
        msg := strings.ToLower(err.Error())
        return strings.Contains(msg, "unique constraint") ||
                strings.Contains(msg, "duplicate key")
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package services – MessageService
//
// This file implements MessageService, the application-level component that
// owns the lifecycle of chat messages and assistant replies. It validates
// inputs, checks chat ownership, performs retrieval over the configured
// search.Index, and persists the user/assistant message pair atomically.
//
// Optional enhancement: it also auto-generates a chat title from the first
// user prompt when the chat still has a default/empty title.
//
// Observability: all public methods are OpenTelemetry-instrumented; spans
// include chat/user identifiers and pagination parameters where applicable.

package services

import (
        "context"
        "regexp"
        "sort"
        "strings"
        "unicode"
        "unicode/utf8"

        "gorm.io/gorm"

        "github.com/tbourn/go-chat-backend/internal/domain"
        "github.com/tbourn/go-chat-backend/internal/repo"
        "github.com/tbourn/go-chat-backend/internal/search"

        // OpenTelemetry
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

const (
        roleUser      = "user"
        roleAssistant = "assistant"

        // default titles we consider “placeholder” and eligible for auto-generation
        defaultTitleNew      = "New chat"
        defaultTitleUntitled = "Untitled"
)

// MessageService coordinates message persistence and retrieval-based answers.
type MessageService struct {
        DB        *gorm.DB
        Index     search.Index
        Threshold float64

        // Optional guards
        MaxPromptRunes int
        MaxReplyRunes  int

        // Title generation config
        TitleLocale language.Tag
        TitleMaxLen int
}

// Answer validates prompt, verifies chat, retrieves a reply, and persists both
// user and assistant messages atomically. It may auto-generate a chat title.
func (s *MessageService) Answer(ctx context.Context, userID, chatID, prompt string) (*domain.Message, error) <span class="cov3" title="7">{
        tr := otel.Tracer("services/MessageService")
        ctx, span := tr.Start(ctx, "Answer",
                trace.WithAttributes(
                        attribute.String("chat.id", chatID),
                        attribute.String("user.id", userID),
                ),
        )
        defer span.End()

        // Normalize &amp; validate prompt
        prompt = strings.TrimSpace(prompt)
        if prompt == "" </span><span class="cov1" title="1">{
                return nil, ErrEmptyPrompt
        }</span>
        <span class="cov3" title="6">if s.MaxPromptRunes &gt; 0 &amp;&amp; utf8.RuneCountInString(prompt) &gt; s.MaxPromptRunes </span><span class="cov1" title="1">{
                return nil, ErrTooLong
        }</span>

        // Ensure the chat exists and belongs to the user
        <span class="cov3" title="5">chat, err := repo.GetChat(ctx, s.DB, chatID, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, ErrChatNotFound
        }</span>

        // Build reply from retrieval
        <span class="cov3" title="4">reply, score := s.retrieve(ctx, prompt)

        // Persist user + assistant (and maybe update title) in one transaction
        var assistantMsg *domain.Message
        err = s.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov3" title="4">{
                if _, err := repo.CreateMessage(tx, chatID, roleUser, prompt, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">m, err := repo.CreateMessage(tx, chatID, roleAssistant, reply, score)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">assistantMsg = m

                // Auto-title if placeholder
                if s.shouldAutoTitle(chat.Title) </span><span class="cov2" title="2">{
                        gen := s.generateTitleFromPrompt(prompt)
                        if gen != "" </span><span class="cov2" title="2">{
                                gen = s.clipTitle(gen)
                                if uerr := tx.Model(&amp;domain.Chat{}).Where("id = ?", chatID).Update("title", gen).Error; uerr == nil </span><span class="cov1" title="1">{
                                        chat.Title = gen
                                }</span>
                        }
                }
                <span class="cov3" title="4">return nil</span>
        })
        <span class="cov3" title="4">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Clip reply length if configured
        <span class="cov3" title="4">if s.MaxReplyRunes &gt; 0 &amp;&amp; utf8.RuneCountInString(assistantMsg.Content) &gt; s.MaxReplyRunes </span><span class="cov1" title="1">{
                runes := []rune(assistantMsg.Content)
                assistantMsg.Content = string(runes[:s.MaxReplyRunes])
        }</span>

        <span class="cov3" title="4">return assistantMsg, nil</span>
}

// ListPage returns paginated messages for a chat.
func (s *MessageService) ListPage(ctx context.Context, chatID string, page, pageSize int) ([]domain.Message, int64, error) <span class="cov3" title="5">{
        tr := otel.Tracer("services/MessageService")
        ctx, span := tr.Start(ctx, "ListPage",
                trace.WithAttributes(
                        attribute.String("chat.id", chatID),
                        attribute.Int("page", page),
                        attribute.Int("page_size", pageSize),
                ),
        )
        defer span.End()

        if page &lt; 1 </span><span class="cov2" title="2">{
                page = 1
        }</span>
        <span class="cov3" title="5">if pageSize &lt;= 0 </span><span class="cov2" title="2">{
                pageSize = 20
        }</span>
        <span class="cov3" title="5">offset := (page - 1) * pageSize

        // Ensure chat exists
        var chatCount int64
        if err := s.DB.WithContext(ctx).Model(&amp;domain.Chat{}).Where("id = ?", chatID).Count(&amp;chatCount).Error; err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>
        <span class="cov3" title="4">if chatCount == 0 </span><span class="cov1" title="1">{
                return nil, 0, ErrChatNotFound
        }</span>

        <span class="cov2" title="3">total, err := repo.CountMessages(s.DB.WithContext(ctx), chatID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>
        <span class="cov2" title="2">if total == 0 </span><span class="cov1" title="1">{
                return []domain.Message{}, 0, nil
        }</span>

        <span class="cov1" title="1">items, err := repo.ListMessagesPage(s.DB.WithContext(ctx), chatID, offset, pageSize)
        return items, total, err</span>
}

// --- Retrieval with precision filtering and re-ranking ---
//
// Strategy:
//  1. Pull TopK=10 candidates.
//  2. Extract query entities/keywords from prompt.
//  3. Build generic "content terms" (non-cap, len&gt;=5, + long quoted phrases), minus generic words.
//  4. Build STRONG entities = long/number entities + compound caps ("Gen Z", "United States")
//     + single proper nouns (capitalized len&gt;=4, e.g., "Nashville").
//  5. Compute overlap (Jaccard + small phrase boosts) and blend with normalized index score.
//  6. Gates: require a content-term hit; enforce strict strong-entity coverage (when query is specific).
//  7. Return 1–2 snippets; only add the second if it matches the same strong entities as top.
func (s *MessageService) retrieve(ctx context.Context, prompt string) (reply string, score *float64) <span class="cov4" title="14">{
        tr := otel.Tracer("services/MessageService")
        _, span := tr.Start(ctx, "retrieve",
                trace.WithAttributes(attribute.String("query", prompt)),
        )
        defer span.End()

        if s.Index == nil </span><span class="cov2" title="2">{
                return "I can’t answer that from the provided data.", nil
        }</span>

        // Pull more candidates than we will answer with
        <span class="cov4" title="12">const K = 10
        results := s.Index.TopK(prompt, K)
        if len(results) == 0 </span><span class="cov1" title="1">{
                if simplified := simplifyQuery(prompt); simplified != "" &amp;&amp; simplified != prompt </span><span class="cov1" title="1">{
                        results = s.Index.TopK(simplified, K)
                }</span>
        }
        <span class="cov4" title="12">if len(results) == 0 </span><span class="cov1" title="1">{
                return "I can’t answer that from the provided data.", nil
        }</span>

        // Extract query terms/entities
        <span class="cov4" title="11">q := extractQueryTerms(prompt)

        // ---------- Build generic "content terms" from the prompt ----------
        lowerPrompt := strings.ToLower(prompt)
        contentSet := make(map[string]struct{})

        // Very generic words to drop from content terms (keeps focus on nouns like "investments", "affluent")
        genericContentDrop := map[string]struct{}{
                "interested": {}, "interest": {}, "interests": {},
                "percentage": {}, "percent": {}, "share": {},
                "likely": {}, "likelihood": {}, "compared": {}, "comparison": {}, "average": {}, "overall": {},
                "people": {}, "person": {},
                "new": {}, "brands": {}, "products": {}, "find": {}, "out": {}, "about": {},
        }

        // Base tokens from the prompt (non-stopword, len&gt;=5)
        for _, tok := range qwordRE.FindAllString(lowerPrompt, -1) </span><span class="cov6" title="47">{
                if _, stop := qStop[tok]; stop </span><span class="cov3" title="6">{
                        continue</span>
                }
                <span class="cov6" title="41">if len(tok) &gt;= 5 </span><span class="cov5" title="21">{
                        if _, drop := genericContentDrop[tok]; drop </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="21">contentSet[tok] = struct{}{}</span>
                }
        }
        // Quoted phrases (&gt;=5 chars when trimmed)
        <span class="cov4" title="11">for _, m := range quotedPhraseRE.FindAllStringSubmatch(prompt, -1) </span><span class="cov0" title="0">{
                for i := 1; i &lt; len(m); i++ </span><span class="cov0" title="0">{
                        if p := strings.ToLower(strings.TrimSpace(m[i])); len(p) &gt;= 5 </span><span class="cov0" title="0">{
                                if _, drop := genericContentDrop[p]; drop </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">contentSet[p] = struct{}{}</span>
                        }
                }
        }
        // Strip capitalized words from content terms (treat them as qualifiers, not topics)
        <span class="cov4" title="11">for _, raw := range alnumRE.FindAllString(prompt, -1) </span><span class="cov6" title="47">{
                if isCapitalized(raw) </span><span class="cov5" title="26">{
                        delete(contentSet, strings.ToLower(raw))
                }</span>
        }

        <span class="cov4" title="11">contentTerms := make([]string, 0, len(contentSet))
        for t := range contentSet </span><span class="cov4" title="11">{
                contentTerms = append(contentTerms, t)
        }</span>
        <span class="cov4" title="11">containsAny := func(sLower string, terms []string) bool </span><span class="cov4" title="8">{
                for _, t := range terms </span><span class="cov4" title="9">{
                        if t != "" &amp;&amp; strings.Contains(sLower, t) </span><span class="cov3" title="6">{
                                return true
                        }</span>
                }
                <span class="cov2" title="2">return false</span>
        }
        // -------------------------------------------------------------------

        // ---------- Strong entities from the query (+ compound caps) ----------
        <span class="cov4" title="11">strongEntities := make(map[string]struct{})

        // Long/number entities from q.entities
        for e := range q.entities </span><span class="cov6" title="35">{
                if isNumber(e) || len(e) &gt;= 5 </span><span class="cov5" title="19">{
                        strongEntities[e] = struct{}{}
                }</span>
        }

        // Compound caps: bigrams/trigrams like "Gen Z", "United States", "New York"
        <span class="cov4" title="11">toks := alnumRE.FindAllString(prompt, -1)
        addPhrase := func(parts ...string) </span><span class="cov5" title="24">{
                ph := strings.ToLower(strings.Join(parts, " "))
                if strings.TrimSpace(ph) != "" </span><span class="cov5" title="24">{
                        strongEntities[ph] = struct{}{}
                }</span>
        }
        <span class="cov4" title="11">for i := 0; i+1 &lt; len(toks); i++ </span><span class="cov6" title="36">{
                a, b := toks[i], toks[i+1]
                // "Gen" + single capital letter (X, Z, etc.)
                if strings.EqualFold(a, "Gen") &amp;&amp; len(b) == 1 &amp;&amp; isCapitalized(b) </span><span class="cov4" title="8">{
                        addPhrase(a, b) // → "gen z"
                }</span>
                // consecutive capitalized words → bigram (and maybe trigram)
                <span class="cov6" title="36">if isCapitalized(a) &amp;&amp; isCapitalized(b) </span><span class="cov4" title="12">{
                        addPhrase(a, b)
                        if i+2 &lt; len(toks) </span><span class="cov4" title="11">{
                                c := toks[i+2]
                                if isCapitalized(c) </span><span class="cov3" title="4">{
                                        addPhrase(a, b, c)
                                }</span>
                        }
                }
        }

        // Single proper nouns (capitalized len&gt;=4), e.g., "Nashville"
        <span class="cov4" title="11">for _, w := range toks </span><span class="cov6" title="47">{
                if isCapitalized(w) &amp;&amp; utf8.RuneCountInString(w) &gt;= 4 </span><span class="cov4" title="10">{
                        strongEntities[strings.ToLower(w)] = struct{}{}
                }</span>
        }

        // Count hits of strong entities in a snippet
        <span class="cov4" title="11">countStrongHits := func(snippet string) (int, map[string]struct{}) </span><span class="cov4" title="12">{
                hit := make(map[string]struct{}, len(strongEntities))
                if len(strongEntities) == 0 </span><span class="cov1" title="1">{
                        return 0, hit
                }</span>
                <span class="cov4" title="11">sn := strings.ToLower(snippet)
                for e := range strongEntities </span><span class="cov6" title="35">{
                        if e != "" &amp;&amp; strings.Contains(sn, e) </span><span class="cov5" title="27">{
                                hit[e] = struct{}{}
                        }</span>
                }
                <span class="cov4" title="11">return len(hit), hit</span>
        }

        // Required hits based on strong entities
        <span class="cov4" title="11">requiredHits := 0
        switch n := len(strongEntities); </span>{
        case n &gt;= 2:<span class="cov4" title="8">
                requiredHits = 2</span>
        case n == 1:<span class="cov2" title="2">
                requiredHits = 1</span>
        default:<span class="cov1" title="1">
                requiredHits = 0</span>
        }
        // -------------------------------------------------------------------

        // Normalize index scores to [0,1]
        <span class="cov4" title="11">maxScore := 0.0
        for _, r := range results </span><span class="cov4" title="14">{
                if r.Score &gt; maxScore </span><span class="cov4" title="11">{
                        maxScore = r.Score
                }</span>
        }
        <span class="cov4" title="11">if maxScore == 0 </span><span class="cov0" title="0">{
                maxScore = 1
        }</span>

        <span class="cov4" title="11">type cand struct {
                text         string
                indexScore   float64
                overlapRel   float64
                combined     float64
                strongEntHit map[string]struct{} // which strong query entities this snippet contains
        }

        // Floors
        const strictFloor = 0.20  // used only when query has 0–1 strong entities
        const lenientFloor = 0.10 // when strong entities satisfied (or none)

        cands := make([]cand, 0, len(results))
        for _, r := range results </span><span class="cov4" title="14">{
                clean := stripMarkdownTablesToLines(strings.TrimSpace(r.Snippet))
                if clean == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="14">sLower := strings.ToLower(clean)

                ov := overlapRelevance(clean, q) // [0,1]
                ns := r.Score / maxScore         // [0,1]
                combined := 0.5*ns + 0.5*ov

                // 1) Content-term gate: if query has content terms, require at least one in snippet
                if len(contentTerms) &gt; 0 &amp;&amp; !containsAny(sLower, contentTerms) </span><span class="cov2" title="2">{
                        continue</span>
                }

                // 2) Strong-entity gate
                <span class="cov4" title="12">hitCount, hitSet := countStrongHits(clean)

                if requiredHits &gt;= 2 </span><span class="cov4" title="9">{
                        // Query is specific → REQUIRE at least 2 strong-entity hits (no overlap escape)
                        if hitCount &lt; 2 </span><span class="cov2" title="2">{
                                continue</span>
                        }
                } else<span class="cov2" title="3"> if requiredHits == 1 </span><span class="cov2" title="2">{
                        // Query has one strong entity → require it, or strong overlap as rare fallback
                        if hitCount &lt; 1 &amp;&amp; ov &lt; strictFloor </span><span class="cov1" title="1">{
                                continue</span>
                        }
                } else<span class="cov1" title="1"> {
                        // No strong entities in query → still avoid trivial snippets
                        if ov &lt; lenientFloor &amp;&amp; utf8.RuneCountInString(clean) &lt; 12 </span><span class="cov1" title="1">{
                                continue</span>
                        }
                }

                // Small tie-break boost for better strong-entity coverage
                <span class="cov4" title="8">if hitCount &gt; requiredHits </span><span class="cov3" title="6">{
                        combined += 0.03
                }</span>

                <span class="cov4" title="8">cands = append(cands, cand{
                        text:         clean,
                        indexScore:   r.Score,
                        overlapRel:   ov,
                        combined:     combined,
                        strongEntHit: hitSet,
                })</span>
        }

        // NEW: decline if nothing passes the precision gates
        <span class="cov4" title="11">if len(cands) == 0 </span><span class="cov3" title="5">{
                return "I can’t answer that from the provided data.", nil
        }</span>

        // Sort by combined descending
        <span class="cov3" title="6">sort.Slice(cands, func(i, j int) bool </span><span class="cov2" title="2">{ return cands[i].combined &gt; cands[j].combined }</span>)

        <span class="cov3" title="6">top := cands[0]

        // Threshold on blended score
        thr := s.Threshold
        if thr &lt;= 0 </span><span class="cov1" title="1">{
                thr = 0.20
        }</span>
        <span class="cov3" title="6">if top.indexScore &lt; thr </span><span class="cov1" title="1">{
                return "I can’t answer that from the provided data.", nil
        }</span>

        // Only add a second if it's close AND covers at least the same strong entities as top.
        <span class="cov3" title="5">out := top.text
        if len(cands) &gt; 1 &amp;&amp; cands[1].combined &gt;= top.combined*0.9 </span><span class="cov1" title="1">{
                ok := true
                for e := range top.strongEntHit </span><span class="cov3" title="4">{
                        if _, hit := cands[1].strongEntHit[e]; !hit </span><span class="cov0" title="0">{
                                ok = false
                                break</span>
                        }
                }
                <span class="cov1" title="1">if ok </span><span class="cov1" title="1">{
                        out = out + "\n" + cands[1].text
                }</span>
        }

        <span class="cov3" title="5">v := top.indexScore
        return collapseWhitespaceLines(out), &amp;v</span>
}

// shouldAutoTitle reports whether the current title is a placeholder.
func (s *MessageService) shouldAutoTitle(current string) bool <span class="cov4" title="8">{
        t := strings.TrimSpace(strings.ToLower(current))
        return t == "" || t == strings.ToLower(defaultTitleNew) || t == strings.ToLower(defaultTitleUntitled)
}</span>

// generateTitleFromPrompt derives a concise title from the prompt.
func (s *MessageService) generateTitleFromPrompt(prompt string) string <span class="cov3" title="6">{
        prompt = strings.TrimSpace(prompt)
        if prompt == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov3" title="5">toks := titleWordRE.FindAllString(strings.ToLower(prompt), -1)
        if len(toks) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov3" title="4">titleCaser := cases.Title(s.TitleLocaleOrDefault())
        out := make([]string, 0, 8)

        for _, w := range toks </span><span class="cov5" title="29">{
                if _, skip := titleStopWords[w]; skip </span><span class="cov4" title="13">{
                        continue</span>
                }
                <span class="cov5" title="16">out = append(out, titleCaser.String(w))
                if len(out) &gt;= 8 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov3" title="4">if len(out) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="3">return strings.Join(out, " ")</span>
}

// clipTitle truncates a generated title to the configured maximum rune length.
func (s *MessageService) clipTitle(title string) string <span class="cov3" title="4">{
        max := s.TitleMaxLen
        if max &lt;= 0 </span><span class="cov1" title="1">{
                max = 60
        }</span>
        <span class="cov3" title="4">if utf8.RuneCountInString(title) &gt; max </span><span class="cov2" title="3">{
                return string([]rune(title)[:max])
        }</span>
        <span class="cov1" title="1">return title</span>
}

// TitleLocaleOrDefault returns the configured locale for casing or English if unset.
func (s *MessageService) TitleLocaleOrDefault() language.Tag <span class="cov3" title="6">{
        if s.TitleLocale == language.Und </span><span class="cov3" title="5">{
                return language.English
        }</span>
        <span class="cov1" title="1">return s.TitleLocale</span>
}

// --- Title generation helpers ---

// Extract Unicode letters with optional trailing numbers (e.g., "gwi2025").
var titleWordRE = regexp.MustCompile(`[\p{L}]+[\p{N}]*`)

// Minimal English stop-words set for compact titles.
var titleStopWords = map[string]struct{}{
        "the": {}, "a": {}, "an": {}, "and": {}, "or": {}, "of": {}, "to": {}, "in": {},
        "is": {}, "are": {}, "for": {}, "on": {}, "with": {}, "by": {}, "from": {},
        "at": {}, "as": {}, "that": {}, "this": {}, "it": {}, "be": {}, "was": {}, "were": {},
}

// --- Query simplification for retrieval fallback ---

// qwordRE: words (letters/digits). We build a keyword query from these.
var qwordRE = regexp.MustCompile(`[\p{L}\p{N}]+`)

// qStop: words to drop when simplifying the question to keywords.
var qStop = map[string]struct{}{
        "the": {}, "a": {}, "an": {}, "and": {}, "or": {}, "of": {}, "to": {}, "in": {},
        "is": {}, "are": {}, "for": {}, "on": {}, "with": {}, "by": {}, "from": {},
        "at": {}, "as": {}, "that": {}, "this": {}, "it": {}, "be": {}, "was": {}, "were": {},
        "how": {}, "much": {}, "more": {}, "likely": {}, "do": {}, "does": {}, "what": {}, "which": {},
        "new": {}, "brands": {}, "products": {}, "find": {}, "out": {}, "about": {},
}

// simplifyQuery converts a long NL question into a compact keyword string.
func simplifyQuery(s string) string <span class="cov3" title="4">{
        toks := qwordRE.FindAllString(strings.ToLower(s), -1)
        if len(toks) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="3">keep := make([]string, 0, len(toks))
        for _, t := range toks </span><span class="cov5" title="22">{
                if _, stop := qStop[t]; stop </span><span class="cov4" title="14">{
                        continue</span>
                }
                <span class="cov4" title="8">keep = append(keep, t)</span>
        }
        <span class="cov2" title="3">if len(keep) == 0 </span><span class="cov1" title="1">{
                // nothing left after filtering; fall back to all tokens
                return strings.Join(toks, " ")
        }</span>
        <span class="cov2" title="2">return strings.Join(keep, " ")</span>
}

// --- Markdown table cleanup utilities ---

// Matches a table row and a separator row like: | --- | :---: | ---: |
var (
        mdTableRow = regexp.MustCompile(`^\s*\|.*\|\s*$`)
        mdSepRow   = regexp.MustCompile(`^\s*\|?\s*:?-{3,}:?\s*(\|\s*:?-{3,}:?\s*)+\|?\s*$`)
)

// stripMarkdownTablesToLines converts markdown table blocks into one-line facts,
// skipping header &amp; '---' separator lines, and preserving non-table lines.
func stripMarkdownTablesToLines(s string) string <span class="cov5" title="16">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov4" title="15">lines := strings.Split(s, "\n")
        out := make([]string, 0, len(lines))

        i := 0
        for i &lt; len(lines) </span><span class="cov5" title="20">{
                line := strings.TrimSpace(lines[i])

                // Detect a markdown table by header row + separator row
                if mdTableRow.MatchString(line) &amp;&amp; i+1 &lt; len(lines) &amp;&amp; mdSepRow.MatchString(strings.TrimSpace(lines[i+1])) </span><span class="cov2" title="2">{
                        // Skip header + separator
                        i += 2

                        // Consume body rows; keep cells but drop pipes
                        for i &lt; len(lines) &amp;&amp; mdTableRow.MatchString(strings.TrimSpace(lines[i])) </span><span class="cov2" title="2">{
                                row := strings.TrimSpace(lines[i])
                                row = strings.TrimPrefix(row, "|")
                                row = strings.TrimSuffix(row, "|")
                                cells := strings.Split(row, "|")
                                for j := range cells </span><span class="cov3" title="4">{
                                        cells[j] = strings.TrimSpace(cells[j])
                                }</span>
                                <span class="cov2" title="2">cleaned := strings.Join(cells, " ")
                                if cleaned != "" </span><span class="cov2" title="2">{
                                        out = append(out, cleaned)
                                }</span>
                                <span class="cov2" title="2">i++</span>
                        }
                        <span class="cov2" title="2">continue</span>
                }

                // Non-table line: keep if non-empty
                <span class="cov5" title="18">if line != "" </span><span class="cov4" title="15">{
                        out = append(out, line)
                }</span>
                <span class="cov5" title="18">i++</span>
        }

        <span class="cov4" title="15">return strings.Join(out, "\n")</span>
}

// collapseWhitespaceLines trims each line, collapses internal whitespace to a single
// space, and drops empty lines entirely.
func collapseWhitespaceLines(s string) string <span class="cov3" title="7">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov3" title="6">s = strings.ReplaceAll(s, "\r\n", "\n")
        raw := strings.Split(s, "\n")
        out := make([]string, 0, len(raw))
        for _, ln := range raw </span><span class="cov4" title="11">{
                parts := strings.Fields(ln)
                if len(parts) == 0 </span><span class="cov2" title="2">{
                        continue</span>
                }
                <span class="cov4" title="9">out = append(out, strings.Join(parts, " "))</span>
        }
        <span class="cov3" title="6">return strings.Join(out, "\n")</span>
}

// --- Precision helpers ---

var (
        quotedPhraseRE = regexp.MustCompile(`"([^"]+)"|‘([^’]+)’|“([^”]+)”|\'([^\']+)\'`)
        alnumRE        = regexp.MustCompile(`[\p{L}\p{N}]+`)
)

// queryTerms holds both tokens and strong "entities".
type queryTerms struct {
        allTokens   map[string]struct{}
        entities    map[string]struct{} // quoted phrases, numbers, Capitalized words, long tokens
        entitySlice []string            // for quick iteration/phrase checks
}

// extractQueryTerms pulls tokens and entities from the prompt.
func extractQueryTerms(prompt string) queryTerms <span class="cov4" title="12">{
        p := strings.TrimSpace(prompt)
        lower := strings.ToLower(p)

        tokens := make(map[string]struct{})
        for _, t := range alnumRE.FindAllString(lower, -1) </span><span class="cov6" title="55">{
                if _, stop := qStop[t]; stop </span><span class="cov3" title="7">{
                        continue</span>
                }
                <span class="cov6" title="48">tokens[t] = struct{}{}</span>
        }

        <span class="cov4" title="12">entities := make(map[string]struct{})

        // quoted phrases
        for _, m := range quotedPhraseRE.FindAllStringSubmatch(p, -1) </span><span class="cov1" title="1">{
                for i := 1; i &lt; len(m); i++ </span><span class="cov3" title="4">{
                        if m[i] != "" </span><span class="cov1" title="1">{
                                ph := strings.TrimSpace(m[i])
                                if ph != "" </span><span class="cov1" title="1">{
                                        entities[strings.ToLower(ph)] = struct{}{}
                                }</span>
                        }
                }
        }

        // numbers &amp; capitalized words &amp; long tokens
        <span class="cov4" title="12">for _, raw := range alnumRE.FindAllString(p, -1) </span><span class="cov6" title="55">{
                lc := strings.ToLower(raw)
                if _, stop := qStop[lc]; stop </span><span class="cov3" title="7">{
                        continue</span>
                }
                <span class="cov6" title="48">if isNumber(raw) || isCapitalized(raw) || len(lc) &gt;= 6 </span><span class="cov6" title="41">{
                        entities[lc] = struct{}{}
                }</span>
        }

        <span class="cov4" title="12">es := make([]string, 0, len(entities))
        for k := range entities </span><span class="cov6" title="42">{
                es = append(es, k)
        }</span>
        <span class="cov4" title="12">return queryTerms{
                allTokens:   tokens,
                entities:    entities,
                entitySlice: es,
        }</span>
}

func isNumber(s string) bool <span class="cov7" title="88">{
        hasDigit := false
        for _, r := range s </span><span class="cov10" title="488">{
                if unicode.IsDigit(r) </span><span class="cov5" title="16">{
                        hasDigit = true
                }</span> else<span class="cov9" title="472"> if !(unicode.IsLetter(r) || r == '.' || r == ',' || r == '%') </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov7" title="87">return hasDigit</span>
}

func isCapitalized(s string) bool <span class="cov8" title="223">{
        rs := []rune(s)
        if len(rs) == 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="222">return unicode.IsUpper(rs[0])</span>
}

// overlapRelevance computes a simple Jaccard overlap between query tokens and snippet tokens,
// with small boosts for exact entity phrase matches.
func overlapRelevance(snippet string, q queryTerms) float64 <span class="cov5" title="18">{
        if len(q.allTokens) == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov5" title="17">snippetLower := strings.ToLower(snippet)
        sTokens := make(map[string]struct{})
        for _, t := range alnumRE.FindAllString(snippetLower, -1) </span><span class="cov7" title="102">{
                sTokens[t] = struct{}{}
        }</span>

        <span class="cov5" title="17">inter := 0
        for t := range q.allTokens </span><span class="cov7" title="65">{
                if _, ok := sTokens[t]; ok </span><span class="cov6" title="54">{
                        inter++
                }</span>
        }
        <span class="cov5" title="17">union := len(sTokens) + len(q.allTokens) - inter
        if union == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov5" title="17">j := float64(inter) / float64(union)

        // phrase/entity boost
        boost := 0.0
        for _, e := range q.entitySlice </span><span class="cov6" title="61">{
                if e == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="61">if strings.Contains(snippetLower, e) </span><span class="cov6" title="55">{
                        boost += 0.06 // small additive boost per entity match
                }</span>
        }
        <span class="cov5" title="17">if boost &gt; 0.24 </span><span class="cov3" title="7">{
                boost = 0.24 // cap
        }</span>
        <span class="cov5" title="17">score := j + boost
        if score &gt; 1.0 </span><span class="cov2" title="2">{
                score = 1.0
        }</span>
        <span class="cov5" title="17">return score</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package sysutil

import (
        "strings"

        "github.com/rs/zerolog"
)

// setLogLevel configures the global zerolog level based on a string value.
// Supported values (case-insensitive): debug, info, warn, error, fatal, panic.
func SetLogLevel(lvl string) <span class="cov8" title="10">{
        switch strings.ToLower(strings.TrimSpace(lvl)) </span>{
        case "debug":<span class="cov3" title="2">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "info", "":<span class="cov3" title="2">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "warn", "warning":<span class="cov3" title="2">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "error":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        case "fatal":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
        case "panic":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.PanicLevel)</span>
        default:<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        }
}

// isTruthy reports whether an environment variable string should be considered true.
// Accepted values (case-insensitive): "1", "true", "yes", "y", "on".
func IsTruthy(v string) bool <span class="cov10" title="15">{
        switch strings.ToLower(strings.TrimSpace(v)) </span>{
        case "1", "true", "yes", "y", "on":<span class="cov7" title="7">
                return true</span>
        default:<span class="cov7" title="8">
                return false</span>
        }
}

// firstNonEmpty returns the first non-empty string from a variadic list.
// If all values are empty, it returns "".
func FirstNonEmpty(vals ...string) string <span class="cov5" title="4">{
        for _, v := range vals </span><span class="cov6" title="6">{
                if strings.TrimSpace(v) != "" </span><span class="cov3" title="2">{
                        return v
                }</span>
        }
        <span class="cov3" title="2">return ""</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package utils provides small, generic helper functions used across
// different layers of the application. These utilities are independent
// of domain or business logic.
package utils

import "strconv"

// AtoiDefault converts a string to an int using strconv.Atoi.
// If the string is empty or cannot be parsed as an integer,
// it returns the provided default value instead.
//
// Example:
//
//        n := utils.AtoiDefault("42", 0) // returns 42
//        n = utils.AtoiDefault("", 10)   // returns 10
//        n = utils.AtoiDefault("x", 5)   // returns 5
func AtoiDefault(s string, def int) int <span class="cov10" title="29">{
        if s == "" </span><span class="cov7" title="11">{
                return def
        }</span>
        <span class="cov8" title="18">if n, err := strconv.Atoi(s); err == nil </span><span class="cov8" title="15">{
                return n
        }</span>
        <span class="cov3" title="3">return def</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
